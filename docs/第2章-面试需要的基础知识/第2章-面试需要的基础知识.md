# 第2章-面试需要的基础知识

## 编程语言

* 由于本人目前主要使用C++，因此本书以C++形式展现。

### C++

语言面试有三种类型：

1. 直接询问应聘者对于C++概念的理解：
    * C++中，有哪四个与类型转换相关的关键字？这些关键字各有什么特点，应该在什么场合下使用？
    * 定义一个空的类型，里面没有任何成员变量和成员函数对该类型求sizeof，得到的结果是什么？为什么不是0？
      * 答案是1。空类型的实例中不包括不论什么信息，本来求sizeof应该是0，可是当我们声明该类型实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。
      * 至于占用多少内存。由编译器决定。
      * Visual Studio中每一个空类型的实例占用1字节的空间。
    * 如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof，得到的结果是多少？
      * 答案还是1。调用构造函数和析构函数仅仅须要知道函数的地址就可以，而这些函数的地址仅仅与类型相关。而与类型的实例无关，编译器也不会由于这两个函数而在实例内加入不论什么额外的信息。
    * 如果把析构函数标记为虚函数呢？
      * C++编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每个实例中加入一个指向虚函数表的指针，在32位的机器上，一个指针占4字节的空间。因此求sizeof得到4，假设是64位的机器，一个指针占8字节的空间。因此求sizeof得到8.

2. 面试官拿出事先准备好的代码，让应聘者分析代码的结果。

    ```cpp
    #include <iostream>

    class A{

    private:
        int value;
        
    public:
        A(int n){
        
            value = n;
        }
        
        A(A other){
        
            value = other.value;
        }
        
        void Print(){
        
            std::cout<<value<<std::endl;
        }
    };

    int main(int argc, const char * argv[]) {

        A a = 10;
        A b = a;
        b.Print();
        
        return 0;
    }
    ```

    选择A.编译错误       B.编译成功，执行时程序崩溃             C.编译执行正常。输出10

    答案是A。编译出错。

    在上述代码中，复制构造函数A(A other)传入的參数是A的一个实例。因为是传值參数，我们把形參拷贝到实參会调用复制构造函数。因此假设同意复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无休止恶递归调用从而导致栈溢出。因此C++标准不同意复制构造函数传值參数。

    在Visual Studio和GCC中，都会编译出错。要解决问题，就是把传值參数改动为常量引用。

    代码例如以下：

    ```cpp
    A(A const &other)
    {
        value = other.value;
    }
    ```

3. 写代码定义一个类型或者实现一个成员函数。

推荐：

* 《Effective C++》
* 《C++ Primer》
* 《深度探索C++对象模型》
* 《The C++ Programming Language》

## 剑指offer面试题1--赋值运算符函数

题目描述：如下为类型CMyString的声明，请为该类型添加赋值运算符函数(拷贝赋值运算符)。

```cpp
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);
      
private:
    char* m_pData;
};
```

[面试题1：赋值运算符函数 c++实现](../../src/01_AssignmentOperator/AssignmentOperator.cpp)

解决该问题应该首先注意下面几点：

1. 是否把返回值的类型声明为该类型的引用。并在函数结束前返回实例自身的引用（即*this）。只有返回一个引用，才可以允许连续赋值。否则如果函数的返回值是void，应用该赋值对象符将不能做连续赋值。如果有三个CMyString对象，str1,str2,str3,在程序中语句`str1=str2=str3`将不能通过编译。

2. 是否把传入的參数的类型声明为`常量引用`。假设传入的參数不是引用而是实例，那么从形參到实參会调用一次复制构造函数。把參数声明为引用能够避免这种无谓的消耗，能提高代码的效率。同一时候，我们在赋值运算符函数内不会改变传入的实例的状态。因此应该为传入的引用參数加上constkeyword。

3. 是否释放实例自身已有的内存。假设我们忘记在分配新内存之前释放自身已有的空间，程序将出现`内存泄露`。

4. 是否推断传入的參数和当前的实例`(*this)`是不是同一个实例。假设是同一个，则不进行赋值操作，直接返回。假设事先不推断就进行赋值，那么在释放实例自身的内存的时候就会导致严重的问题：当`*this`和传入的參数是同一个实例时，那么一旦释放了自身的内存。传入的參数的内存也同一时候被释放了，因此再也找不到须要赋值的内容了。

### 经典的解法，适用于初级程序员

```cpp
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this == &str)
        return *this;

    delete []m_pData;
    m_pData = nullptr;

    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
```

适用于应届毕业生或C++初级程序员，对于高级程序员需要更高的要求。

* 可能导致程序崩溃：再分配内存前先用delete释放了实例m_pData的内存，此时内存不足则会导致new char 抛出异常，则m_pData将会是一个空指针，非常荣誉导致成或许崩溃。

### 考虑异常安全的解法，高级程序员必备

```cpp
// 考虑异常安全的解法，高级程序员必备
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this != &str)
    {
        CMyString strTemp(str);

        char* pTemp = strTemp.m_pData;
        strTemp.m_pData = m_pData;
        m_pData = pTemp;
    }

    return *this;
}
```

实现异常安全性：

* 先用new分配运算符，再用delete释放已有的内容。
* 先创建一个临时变量，再交换临时实例和原来的实例。

### 为什么要先释放原来对象原有的内存资源呢？

1. 内存泄漏：成员有指针，如果不释放原对象的内存，当新的数据被拷贝过来后，原内存将无法通过任何指针访问，从而变成无法释放的“悬挂”内存，造成内存泄漏。

2. 资源浪费：每次赋值都只是简单地复制数据而不清理旧数据，会使得每次赋值操作都增加新的内存消耗，即使这些内存很快变得不再可访问。

3. 潜在的逻辑错误：如果对象持有指向某种资源（不仅仅是内存，也可能是文件句柄、网络连接等）的指针，不正确地管理这些资源的生命周期可能会导致程序行为异常或崩溃。

因此，在执行赋值操作前先释放原有的内存资源是一种“深拷贝”的做法，确保了每个对象独立拥有其数据的副本，避免了上述问题，同时也使得对象的状态保持一致性和可预测性。这是面向对象编程中管理资源、确保对象完整性和健壮性的重要原则。

### 启示

1. 明确定义：如果类中没有显式定义复制构造函数，编译器会自动生成一个默认的复制构造函数，该构造函数执行逐个成员的浅复制。对于含有指针成员或动态分配内存的类，这可能导致资源重复释放或悬空指针问题。因此，当类中有指针或动态分配的资源时，应显式定义复制构造函数以执行深复制。
2. 深复制与浅复制：确保复制构造函数执行深复制，即不仅复制指针成员本身，还要复制指针所指向的数据。这意味着如果类中有指针成员指向堆上的数据，复制构造函数应该为新对象分配新的内存，并复制原来数据的内容。
3. 资源管理：如果类负责管理资源（如文件句柄、网络连接等），复制构造函数需要考虑资源的正确复制或共享策略，避免资源泄露或不当使用。
4. 自引用问题：当类的成员是指向自身类型的指针或引用时，需要特别小心处理自复制的情况，避免无限递归或循环引用的问题。
5. 使用成员初始化列表：为了效率和正确性，建议在复制构造函数的初始化列表中初始化成员，特别是对于非基本类型的成员。
6. 构造函数委托：C++11起，如果类中已有其他构造函数完成了大部分初始化工作，复制构造函数可以通过委托构造（使用:语法）来调用它们，以减少代码重复。
7. 异常安全：复制构造函数应设计为异常安全的，即在发生异常时，能够保持对象的不变性和资源的正确状态。
8. 复制省略优化（C++11起）：了解并利用C++编译器的复制省略和移动语义，这可以在某些情况下自动优化复制操作，提高效率。

## 剑指offer面试题2--实现Singleton模式

题目描述：设计一个类，我们只能生成该类的一个实例。

* 对于C++而言，没有静态构造函数，因此只能使用局部静态变量。
* 双检锁（Double-Checked Locking, DCL）的版本，可能存在`reorder`问题。C++11后引入原子操作可以有效解决双检锁的问题。

本题原版是介绍C#的单例模式，因此此处给出C#版本：
[面试题2：实现Singleton模式 C#实现](../../src/02_Singleton/Program.cs)

此处我结合题目情况，给出C++版本：
[面试题2：实现Singleton模式 C++实现](../../src/02_Singleton/Singleton.cpp)

### 启示

1. 深入理解不同语言的特性，同一种设计模式/设计方法使用不同的语言实现时，受特性影响，可能实现会有差距，甚至有的方案就行不通。
2. 深入理解并学习设计模式，使之灵活、正确应用于日常开发中。
3. “双检锁”是多线程语言中的普遍操作，也都会面临双检锁reorder问题。需要使用原子操作或具体语言特性解决。

## 剑指offer面试题3--数组中的重复数字

### 题目一：找出数组中重复的数字

题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2或者3。

#### 最简单的方法--排序后相邻元素两两比较

先对数组排序，如果有重复元素排序后将会相邻。然后相邻元素两两比较，有相等的情况就找到了重复数字。排序一个长度为n的数组时间复杂度为O(nlogn)。

时间复杂度：O(nlogn)

#### 使用哈希表

将数组中的每个元素都加入哈希表

时间复杂度：O(n)
空间复杂度：O(n)

#### 利用题干信息——长度为n的数组里的所有数字都在0到n-1的范围内

上面的实现对于任意数组都是通用的。**我们要善于抓住题干的已知信息**，比如题目中明确说明了长度为n的数组里面的数字全是[0, n-1]之间的。从这句话能获得什么信息呢？如果将数组排好序，那么数组每一个位置都有numbers[i] = i，如果有重复元素，说明[0, n-1]中某些数字空缺了，某些数字有多个。那么必然有某个j !=i的numbers[j] == numbers[i]，如果找到满足上述条件的数字，就找到了重复数字。

* 如果值i没有在正确的位置（满足numbers[i] == i），通过交换两个元素，将值i放到正确的位置。这个过程可以看成是排序。
* 当numbers[i] != i，若令numbers[i] = j，显然j != i；如果此时numbers[j] == numbers[i]说明在与i不同的位置j找到重复元素。否则重复上一步。

[面试题3：找出数组中重复的数字 C++实现](../../src/03_01_DuplicationInArray/FindDuplication.cpp)

[面试题3：找出数组中重复的数字 Java实现](../../src/03_01_DuplicationInArray/FindDuplicate.java)

代码中尽管有一个两重循环，但是每个数字只需交换一两次就能被放在正确的位置上，因此总的时间复杂度为O(n)。而且所有操作都在原数组上进行，没有引入额外的空间，空间复杂度为O(1)。

* 修改了原数组
* 时间复杂度为O(n)
* 空间复杂度为O(1)

### 题目二：不修改数组找出重复的数字

题目描述：
在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。

#### 创建辅助数组进行计算

创建一个长度为N+1的辅助数组，然后逐一把原数组的每个数字复制到辅助数组。如果原数组中被复制的数字是m，则把它复制到辅助数组中位置为m的位置，这样很容易发现哪个数字重复了。

时间复杂度：O(n)
空间复杂度：O(n)

#### 二分查找

**解题思路：**

1. 我们把从 1\~n 的数字从中间的数字 m 分为两部分，前面一半为 1\~m,后面一半为 m+1\~n。
2. 如果 1\~m 的数字的数目超过 m ,那么这一半的区间里一定包含重复的数字;否则，另一半 m+1\~n 的区间里一定包含重复的数字。
3. 我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。

[题目二：不修改数组找出重复的数字 C++实现](../../src/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp)

### 启示

1. 拿到题目后，仔细查看问题的描述和细节问题。比如本题和变题的“不可修改原数组”，会直接导致使用不同的思路解题。
2. 与面试官深入沟通，挖掘需求，给出复合预期的解决方案。

## 剑指offer面试题4--二维数组中的查找

题目描述：
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

根据题目，一个满足要求的二维数组长下面这样。

```cpp
1 2 8 9
2 4 9 12
4 7 10 13
6 8 11 15
```

### 暴力搜索

思路：直接遍历整个二维数组，实现搜索。肯定不满足题意，且时间复杂度高。

时间复杂度：O(n^2)
空间复杂度：O(1)

### 对每一行进行二分查找

思路：每一行的一维数组已经有序，所以使用二分查找在每一行中查找，一旦找到立即返回。对于一个M*N的二维数组，一次二分查找的时间复杂度为O(lg N), M行就是O(Mlg N)。根据上面的表述已经可以很轻松地写出代码了。

```cpp
#include <vector>

class FindIn2DArray {
public:
    /**
     * 我想到的做法，对每一行的一维数组作二分查找.
     * 如果矩阵是M*N的，一次二分查找是O(lg N), M行就是O(Mlg N)
     *
     * @param target 要查找的数
     * @param array  二维数组
     * @return true如果在数组中找到target
     */
    bool Find2(int target, const std::vector<std::vector<int>>& array) {
        if (!array.empty()) {
            for (const auto& row : array) {
                int high = row.size() - 1;
                int low = 0;
                while (low <= high) {
                    int mid = low + (high - low) / 2;
                    if (target > row[mid]) {
                        low = mid + 1;
                    } else if (target < row[mid]) {
                        high = mid - 1;
                    } else {
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
```

代码还可以优化，根据这个二维数组的特点，任意一个位置其右边的所有元素和下边的所有元素都是大于它的。所以当我们按照从上到下的顺序遍历每一行的一维数组时，如果某次有

```cpp
else if (target < array[i][mid]) 
  {high = mid - 1;}
```

那么以后的若干行，都不用再和mid之后的元素比较了。因为array[i][mid]处的元素和它下边、右边的值相比是最小的，这个最小的元素都大于target，下边的、右边的值不用比较也知道比target大。举个例子

```cpp
1 2 8 9 16
2 4 9 12 17
4 7 10 13 18
6 8 11 15 19
```

如果target是7，当在第一行中二分查找时候，target < array[i][mid] = 8 ,high被更新为1， 既然7 < 8，对于8的右边、下边所有元素都是大于7的，无需再比较。所以下次循环中数组应该缩小为

```cpp
2 4
4 7
6 8
```

最开始的想法中，每次循环都将high重新初始化。考虑上面的优化，我们当high的值被更新后，在后续的循环中不再重新被初始化即可。

```cpp
// 优化前
for (int i = 0; i < array.length; i++) {
    int high = array[i].length - 1;
    int low = 0;
}

// 优化后
int high = array[0].length - 1;
for (int i = 0; i < array.length; i++) {
   int low = 0;
}
```

由于是从上到下的顺序遍历每一行，所以优化操作不能用于low。（当然如果是从底向上遍历的顺序，只能优化low而不能优化high）

时间复杂度：O(nlogn)
空间复杂度：O(1)

### 和右上角/左下角元素比较不断缩小范围

上面二分查找对high的优化是个很好的启发，如果我们将target和矩阵中的某一个数比较，如果`target > arr[i][j]`，那么`array[i][j]`的右边列所有元素、下边行的所有元素都有可能含有与target相等的数；同理如果`target < arr[i][j]`，那么`array[i][j]`的左边列所有元素、上边行的所有元素都有可能含有与target相等的数。这样问题就复杂了，编写代码时可能无从下手（到底选择往哪个方向移动？），和矩阵的左上角、右下角也是一个道理。

我们来看右上角/左下角，由于这两个位置对称，现只看右上角。**这个位置在一行中是最大的元素，在一列中是最小的元素。**根据这个特点，当右上角的值大于target，右上角元素那一列都是大于target的，所以可以直接剔除这一列；当右上角的值小于target，右上角元素那一行都是小于target的，所以可以直接剔除这一行；当右上角的值等于target说明找到，立即返回。就这样不断将范围一行一列地缩小...

* 右上角开始：当前遍历树大于目标数，则剔除所在列(j--);小于则剔除所在行(i++)
* 左下角开始：当前遍历树大于目标数，则剔除所在行(i--);小于则剔除所在列(j++)

[二维数组中的查找 c++实现](../../src/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp)

[二维数组中的查找 Java实现](../../src/04_FindInPartiallySortedMatrix/FindIn2DArray.java)

### 启示

1. 遇到类似的数组题、模拟题、树和图等题，试试通过具体的例子找出规律，进而找到解决问题的突破口。
2. 考虑问题要全面，突破传统的思维，比如本题一般都只想到从左上角开始试试，然后忽略掉了其他三个方向，导致发现复杂度很高or可行性很低，进而更换了思路，错过了正解思路。

## 剑指offer面试题5--替换空格

题目描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

### 使用C++库函数replace轻松解决

思路：由于使用Java语言，很容易想到使用库函数。遍历每个字符，如果遇到空格，就直接使用replace方法替换。

```cpp
#include <iostream>
#include <string>

std::string replaceSpaces(const std::string& input) {
    std::string output;
    for (char c : input) {
        if (c == ' ') {
            output.append("%20");
        } else {
            output.push_back(c);
        }
    }
    return output;
}

int main() {
    std::string originalStr = "We Are Happy.";
    std::string replacedStr = replaceSpaces(originalStr);
    std::cout << replacedStr << std::endl;  // 输出: We%20Are%20Happy.
    return 0;
}
```

### 时间复杂度为O(n^2)的解法，不足以拿到Offer

最直观的做法就是从头到尾扫描字符串，每次碰到字符的时候，都进行替换。

对每个空格字符，需要移动后面的O(n)个字符，对于含有n个空格字符的字符串，总的时间复杂度为O(n^2)。
空间复杂度为O(n)。

### 时间复杂度为O(n)的解法，搞定Offer就靠它了--从后往前扫描(双指针拷贝)

本着学习的态度（而不是完成任务），上面的方法虽然简洁，但封装过好的方法掩藏了算法的实现细节。现在我们自己来实现一种比较底层的方法。

按照一般思维，总习惯从左往右处理字符串。当遇见第一个空格时，其后的所有字符都需要右移两个位置；当遇见第二个空格时，其后的字符又要右移...因此很多字符被移动了不止一次。能不能减少移动的次数呢？**从前往后扫描要移动那么多次，不妨反过来从后往前扫描试试。**

* 先遍历一遍原字符串，统计空格字符的个数。
* 由于要将空格（一个字符）变成%20（三个字符），所以需要将原字符串增长2 * 空格数
* 设置两个指针，一个指针oldP指向原字符串的末尾；另一个指针newP指向增长后的新字符串末尾。不断将oldP处的字符移动到newP处，然后两个指针都要左移；如果oldP处字符是空格，就在newP处设置三个字符：按顺序分别是0、2、%，同样的两个指针相应的左移。

按照上面的算法流程，写出如下代码。

[替换空格 C++](../../src/05_ReplaceSpaces/ReplaceSpaces.cpp)

### 易错点

新字符串的长度是原始字符串长度+空格个数*2，而不是3，因为空格为1字节，%20为 3字节，比空格多2个字节。

`char * str`和`char str[]`相同点都是可以直接通过加法取得对应位置的元素，但是不同点是， char * str的值可以改变，而char str[]不能改变。如：

```cpp
char * str = "abc";
str++; //ok
char str1[] = “abc”;
str++; //error
```

char str[]的类型是const char *因此无法修改。
`char str[] = "abc"`中，`str`的长度是4，最后一个元素为`\0`。

```cpp
char str[4] = "abc"; //ok
char str[3] = "abc"; //error
```

### 启示

1. 在有库函数直接实现的情况下，为了极致的性能考虑，需要考虑不同实现的**时间和空间复杂度**，选择最优策略。同时注意"**开发效率**"也是很重要的指标。
2. 本题先计算需要的空间长度对数组扩容，再依次从后向前逐位复制的思路值得学习。对于合并数组的题目很适用。

### 相关题目

题目描述：有两个有序的数组A1和A2，A1末尾有足够空间容纳A2。实现一个函数将A2的所有数字插入到A1中，并且所有数字是有序的。

思路：因为空闲的空间在A1的末尾，所以从后往前比较两个A1和A2的数字，将更大的那个移动到A1的末尾，然后左移指针，继续比较两个数组中的数。当某个数组中的元素被取完了，就直接从另外一个数组取。

比如下面的例子

```cpp
A1 = [1, 2 ,4 ,7, 9, , , ...]
A2 = [3, 5, 8, 10, 12]
```

假设A1的长度为10，现暂时只有5个元素，这个长度刚好能装下A2。从后往前比较A1和A2：12比9大，将12移动到A1[9]中，然后9和10继续比较，10移动到A1[8]中，9和8比较9移动到A1[7]中，如此这般直到扫描完两个数组，所有数字也都有序了。

[MergeTwoSortedArray.java](../../src/05_ReplaceSpaces/MergeTwoSortedArray.java)

## 剑指offer面试题6--从尾到头打印链表

题目描述：输入一个链表的头节点，从尾到头打印链表每个节点的值。

### 使用栈

思路：此题可以使用链表逆序做，但是为了避免修改链表，我们将使别的方法来实现。思路非常简单，首先对链表进行遍历，将结果保存在一个栈中，再对栈中的结果依次出栈就行了。典型的后进先出，使用栈，顺序遍历一遍链表，依次将每个值入栈。得到的就是尾节点在前，头节点在后的列表。

[从尾到头打印链表 C++](../../src/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp)

[从尾到头打印链表 Java](../../src/06_PrintListInReversedOrder/FromTail2Head.java)

```cpp
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        if(!head) return vector<int>();

        //保存到栈内
        stack<ListNode *> temp;
        while(head)
        {
            temp.push(head);
            head = head->next;
        }

        vector<int> result;
        
        //出栈
        while(!temp.empty())
        {
            ListNode *h = temp.top();
            result.push_back(h->val);
            temp.pop();
        }

        return result;
    }
};
```

### 启示

1. 问清楚面试官题目需求，能否改变原链表。决定了你将采取什么方案去解决问题 。

## 剑指offer面试题7--重建二叉树

题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

### 递归

由中序遍历序列和前序或后序任一序列就能确定唯一的一棵二叉树，中序遍历序列是必须要的。

二叉树本来就是一种递归的结构，某个父结点，你可以说它拥有一个左子结点和一个右子结点，也可以说它拥有一棵以左子结点为根的左子树和一颗右子结点为根的右子树。因此二叉树的构建采用递归的方法是一种很自然的想法。

一棵树从上到下可以分解成了左子树、根结点、右子树，对于每一棵子树，又可以继续分解下去...一直到树底的叶子结点。相反，树的构建是从下到上的顺序，叶子结点可以看做最小的子树，这些子树的根结点成为其他结点的左右子结点，于是产生了更大的子树，这些子树继续成为上层结点的左右子结点....一直到根结点的做右子结点也确定下来。

关键是要找到每棵树的根结点，**前序遍历的第一个结点就是树的根结点；在中序遍历里找到这个结点，其左边的结点都是根结点的左子树，其右边的结点都是根结点的右子树。假如根结点左边有M个结点，那么在前序序列中，根结点后的M个结点也是属于根结点的左子树的。前序序列中余下的后面的结点自然属于根结点的右子树。**这样就可以把中序遍历的数组从根结点处分解成左右子树（对应的有两个子数组），然后递归地对这两个子数组执行同样的操作。现在重点是要在子数组中找到根结点——它依然是数组的第一个元素！

比如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}。前序序列可知根结点是1，于是从中序序列可知，{4, 7, 2}属于根结点1的左子树，有3个结点；{5, 3 ,8, 6}属于根结点1的右子树。回到前序序列，除开第一个根结点，其后3个结点{2, 4, 7}就是左子树，余下的{3, 5, 6 ,8}是右子树。按照这些关系可以精确地将数组分解成两个子数组，递归地对两个数组进行同样的操作即可。

实现：
[重建二叉树 C++](../../src/07_ConstructBinaryTree/ConstructBinaryTree.cpp)
[重建二叉树 C++](../../src/07_ConstructBinaryTree/ReConstructTree.java)

```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.empty() || vin.empty())
            return NULL;
        
        return ConstructBinaryTreeCore(pre, vin);
        
    }
    TreeNode *ConstructBinaryTreeCore(const vector<int> &pre, const vector<int> &vin)
    {
        int root_val =  pre[0];
        TreeNode *root = new TreeNode(root_val);

        if(pre.size() == 1)
            return root;
        
        int left_length = 0;
        for(auto var = vin.begin(); var != vin.end(); var++)
        {
            if(*var == root_val)
                break;
            left_length++;
        }
        int right_length = vin.size() - 1 - left_length;

        if(left_length)
            root->left = ConstructBinaryTreeCore(vector<int>(pre.begin() + 1, pre.begin() + 1 + left_length),
                                                 vector<int>(vin.begin(), vin.begin() + left_length));
        if(right_length)
            root->right = ConstructBinaryTreeCore(vector<int>(pre.begin() + 1 + left_length, pre.end()),
                                                  vector<int>(vin.begin() + 1 + left_length, vin.end()));

        return root;
    }
};
```

易错点：
pre.empty() 返回true代表pre为空，否则不为空

### 启示

1. 熟练掌握树的结构和使用。理解树的前序、中序、后序遍历。
2. 找规律，发现前序、中序、后序遍历之间的关系。
3. 理解递归，熟练使用递归遍历二叉树。

## 剑指offer面试题8--二叉树中序遍历的下一个结点

题目描述：
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

### 思路

要找出中序遍历的下一个结点，要分几种情况探讨。

* 如果当前结点的右子结点不为空，那么下一个结点就是以该右子结点为根的子树的最左子结点；
* 如果当前结点的右子结点为空，看它的父结点。此时分两种情况：
  * 如果父结点的右子结点就是当前结点，说明这个结点在中序遍历中已经被访问过了，需要继续往上看其父结点...直到父结点的左子结点是当前结点为止，该父结点就是下一个结点。
  * 如果在一直往上的过程中已经到达根结点，而根结点的父结点为null，这种情况说明当前结点已经是中序序列的最后一个结点了，不存在下一个结点，应该返回null。

[二叉树中序遍历的下一个结点](../../src/08_NextNodeInBinaryTrees/NextNodeInBinaryTrees.cpp)

### 启示

1. 熟悉二叉树的结构和中序遍历，在此基础上全面思考，充分考虑不同的情况。

## 剑指offer面试题9--两个栈实现队列

题目描述：
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

### 两个栈实现队列

解题思路：
刚开始两个栈都是空的，要进队列，可以将元素压入任何一个栈，不妨就压入stack1中，我们知道元素在栈中是后进先出的，因此要出列需要删除stack1最底部的元素，此时stack2派上用场了，将stack1的元素再压入stack2中，现在元素的排列变成了原来插入的顺序，要出列的元素到了栈顶，要完成出列操作就很方便了。若要继续出列，只要stack2不为空，只需继续从stack2中出栈即可，**因为stack2中的栈顶元素就是最先入列的元素。若stack2为空，就将stack1中的元素压入到stack2后，再弹出栈顶元素。**如果要入列，就直接压入stack1中。

总结一下就是：

* stack1专门用于进入队列
* stack2专门用于出队列
* 出列操作。stack2不为空就直接出列；为空就将stack1中所有元素压入stack2中，再弹出栈顶元素。

![两个栈实现队列 C++](../../src/09_QueueWithTwoStacks/QueueWithTwoStacks.cpp)

![两个栈实现队列 java](../../src/09_QueueWithTwoStacks/TwoStackImpQueue.java)

### 相关题目--两个队列实现栈

解题思路：
刚开始两个队列都为空，进栈时，可以进入任意一个队列。不妨默认进入Queue a。后续进栈时操作，哪个队列不为空（将看到，另外一个队列肯定为空）就进入该队列中。出栈操作，最后进入队列的要先出栈，而此时要出栈的元素在队列最后，但是队列只支持在队列头删除，因此将除了最后一个元素之外的所有元素都删除并复制一份到另一个队列Queue another，然后出列最后一个元素即可。此时Queue a成了空队列。之后每次出列操作都像上述以样：将不为空的队列中除最后一个元素的其余元素删除并复制到另一个空队列中，再删除原队列中唯一一个元素并弹出。每次出栈操作后，总有一个队列是空的。又因为进栈时也是进入不为空的那个队列，因此进出栈操作时总有一个队列是空的。

这两个队列不像上面的例子中有明确的分工，在两个队列实现栈的例子中，它们交替实现进栈或出栈的功能。

总结一下：

进栈，进入不为空的那个队列中
出栈，将不为空队列中除倒数最后一个元素外的其余元素移动到另一个空队列中，紧接着弹出原队列的最后一个元素。

[两个队列实现栈 java](../../src/09_QueueWithTwoStacks/TwoQueueImpStack.java)

### 启示

1. 两个栈可以模拟队列，两个队列可以模拟栈。
2. 那张纸模拟一遍思路即可。

## 剑指offer面试题10--斐波那契数列

题目描述:
现在要求输入一个整数n，请你输出斐波那契数列的第n项。
（从0开始，第0项为0）。

[斐波那契数列 C++](../../src/10_Fibonacci/Fibonacci.cpp)

[斐波那契数列 Java](../../src/10_Fibonacci/Fibonacci.java)

### 递归法

根据斐波那契数列的定义式子：`f(n) = f(n-1) + f(n-2)`即可得到递归公式。

```cpp
int fib2(int n) {
    if (n <= 0) 
    {
        return 0;
    }

    if (n == 1) {
        return 1;
    }

    return fib2(n-1) + fib(n-2);
}
```

* 递归法重复计算了很多节点，效率太低，用递归的时间复杂度是以n的指数的方式增长的。
* 因此面试官期待的方法肯定不是递归法。

### 迭代法

可以使用一个`Bottom-Up`的方法，`n=0`时，斐波那契数是`0`，`n=1`时，斐波那契数是`1`，`n=2`时是`0+1 = 2`，所以我们在计算第`n`个数的时候，将前`n-1`个斐波那契数组都计算出来，就可以得到结果了。

即：从底向上的方法：先得到f(0)、f(1)的值，然后根据这两个值计算序列后面的值。

```cpp

class Solution {
public:
    int fibIterative(int n) {
    if (n <= 1) return n;
    int a = 0, b = 1, sum;
    for (int i = 2; i <= n; ++i) {
        sum = a + b;
        a = b;
        b = sum;
    }
    return b;
}
};
```

### 动态规划法

代码和实现思路基本等同于迭代法。

```cpp
class Solution {
public:
    int Fibonacci(int n) {
        vector<int> dp(n+1);
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++)
        {
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[n];
    }
};
```

### 相关题目--青蛙跳台阶

题目描述：
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

#### 思路

到达1级台阶只有1种可能，到达2级台阶有2种可能；可记为f(1) = 1,f(2) = 2。要到达3级台阶，可以选择在1级台阶处起跳，也可以选择在2级台阶处起跳，所以只需求到达1级台阶的可能情况 + 到达2级台阶的可能情况，即f(3) = f(2) +f(1)

同理到达n级台阶，可以在n-1级台阶起跳，也可在n-2级台阶起跳，f(n) = f(n-2)+f(n-1)

可以完美转化为斐波那契数列。

```cpp
public class JumpFloor 
{
public:
    /**
     * @param target 要到达的第n级台阶
     * @return 到达n级台阶总共的跳法可能
     */
    int jumpFloor(int target) {
        if (target <= 0) {
            return 0;
        }
        if (target == 1) {
            return 1;
        }

        int a = 1;
        int b = 2;
        while (target > 1) {
            b = a + b;
            a = b - a;
            target--;
        }
        return a;
    }
}
```

* 本题是经典的"动态规划"类题目

### 相关题目--青蛙跳n级台阶

注意和上题的区别。

到达1级台阶只有1种可能，到达2级台阶有2种可能；可记为f(1) = 1,f(2) = 2。要到达3级台阶，可以选择在1级台阶处起跳，也可以选择在2级台阶处起跳，也可直接跳到3级，所以只需求到达1级台阶的可能情况 + 到达2级台阶的可能情况 + 1，即f(3) = f(2) +f(1) + 1同理到达n级台阶，可以在n-1级台阶起跳，可在n-2、n-1、n-3...级台阶起跳，f(n) = f(n-1)+f(n-2)+f(n-3)...+1,如果令f(n-n) = f(0) = 1,上式可表示为f(n) = f(n-1)+f(n-2)+f(n-3)...+f(n-n)，有了通项公式找出规律也不是难事了，不过还有种更好理解的思路：前n-1级台阶，每级台阶都有两种选择——跳到此或不跳到此，对于最后一级n级，没得选择，必须跳到这里，所以总共有有`2^(n-1)`种跳法。

### 相关题目--矩形覆盖问题

题目描述：
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

思路：
这个问题本质还是斐波那契数列...
覆盖2*n的矩形的方法记为f(n)。

* 当最后一步是竖着放时候，说明前一步已经覆盖了`2*(n-1)`，记为`f(n - 1)`
* 当最后一步是横着放的时候，倒数第二次也必然是横着放的。这个状态已经覆盖了`2* (n-2)`，记为`f(n - 2)`
因为最后一步只有横竖放两种可能，所以将上述两种方法可能性加起来即可。

覆盖`2*1`的矩形只有1种方法，覆盖`2*2`的矩形有横竖`2`种方法。于是`f(1) = 1`, `f(2) = 2`

这和能跳1级也能跳2级的青蛙是一样的。代码直接copy过来就行！

### 启示

1. 学习`一题多解`，拓展思路。学习`多题一解`，将问题转化和抽象为同一个模型。
2. `递归法`是基于问题分解的基本思想，将复杂问题分解为相似的子问题，直到达到简单的基本情况。通过函数自我调用来解决问题，通常基于问题可以分解为更小规模的相似子问题的特性。递归代码往往简洁易懂，但可能会导致栈溢出和重复计算。
   * 特点：递归通过函数自我调用来解决问题，通常基于问题可以分解为更小规模的相似子问题的特性。递归代码往往简洁易懂，但可能会导致栈溢出和重复计算。
   * 适用条件：适用于具有自然递归结构的问题，如树形结构的遍历（如二叉树）、分治策略（如快速排序、归并排序）和部分动态规划问题的基础情况。
   * 注意：递归必须要有一个退出的条件!
3. `迭代法`:迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，跟迭代法相对应的是直接法(或者称为一次解法)，即一次性解决问题。
   * 特点：迭代通常使用循环来逐步逼近问题的解，相对于递归，它更节省内存，避免了栈溢出的风险。但有时代码可读性可能不如递归。
   * 适用条件：几乎任何可以用递归解决的问题都可以转换为迭代法，特别适合那些递归深度大或重复计算多的问题，如斐波那契数列计算、广度优先搜索等。
4. `动态规划（DP）`主要用于求解最优化问题，通过填表的方式来避免子问题的重复计算，它的基础也是分解问题为子问题，但重点在于利用重叠子问题和最优子结构。
   * 特点：动态规划通过解决相互重叠的子问题来避免重复计算，通常使用表格来存储中间结果。它强调最优子结构和重叠子问题。
   * 适用条件：适用于有重叠子问题和最优子结构的问题，如背包问题、最短路径问题、编辑距离等。当问题可以通过定义状态和状态转移方程来描述时，使用动态规划最为高效。
5. `回溯法`则是一种通过试错来寻找所有（或某种）解的方法，适用于解决约束满足问题，通过探索决策树并剪枝来减少搜索空间。
   * 特点：回溯是一种通过试错寻找所有（或一部分）解的方法，采用深度优先搜索策略，并在发现当前路径无法得到解时回溯。通常结合剪枝策略来减少搜索空间。
   * 适用条件：适用于求解约束满足问题，如八皇后问题、图的着色问题、组合总和问题等。当解空间较大且需要探索多种可能性时，回溯法是非常有效的。
6. 迭代和递归的关系和区别
   * 从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到变量新值得编程思想。简单地说，递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。
7. `递归转动态规划`：
   * 当递归问题中存在大量的重复子问题，且具有最优子结构时，可以考虑转换为动态规划。通过建立一个表（数组或矩阵）来存储子问题的解，避免重复计算，从而将时间复杂度从指数级降低到多项式级。例如，斐波那契数列、背包问题等经典问题，自然适合用动态规划来优化递归解法。
8. `递归转回溯法`：
   * 当递归问题涉及在可能的解决方案空间中搜索，且需要考虑多种选择，每种选择又会引出更多的选择时，可能更适合采用回溯法。回溯法通过逐层深入决策树，当发现当前路径不可能得到可行解时及时回溯，避免无效搜索。例如，八皇后问题、图的着色问题等，更适合使用回溯法。

### 易错点

* 注意斐波那契数组是前两个数的和，不是第i个数相加。
* 需要预设斐波那契数列的前两个数
  * f(0) = 0
  * f(1) = 1
