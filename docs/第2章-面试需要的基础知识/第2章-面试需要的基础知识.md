# 第2章-面试需要的基础知识

## 编程语言

* 由于本人目前主要使用C++，因此本书以C++形式展现。

### C++

语言面试有三种类型：

1. 直接询问应聘者对于C++概念的理解：
    * C++中，有哪四个与类型转换相关的关键字？这些关键字各有什么特点，应该在什么场合下使用？
    * 定义一个空的类型，里面没有任何成员变量和成员函数对该类型求sizeof，得到的结果是什么？为什么不是0？
      * 答案是1。空类型的实例中不包括不论什么信息，本来求sizeof应该是0，可是当我们声明该类型实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。
      * 至于占用多少内存。由编译器决定。
      * Visual Studio中每一个空类型的实例占用1字节的空间。
    * 如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof，得到的结果是多少？
      * 答案还是1。调用构造函数和析构函数仅仅须要知道函数的地址就可以，而这些函数的地址仅仅与类型相关。而与类型的实例无关，编译器也不会由于这两个函数而在实例内加入不论什么额外的信息。
    * 如果把析构函数标记为虚函数呢？
      * C++编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每个实例中加入一个指向虚函数表的指针，在32位的机器上，一个指针占4字节的空间。因此求sizeof得到4，假设是64位的机器，一个指针占8字节的空间。因此求sizeof得到8.

2. 面试官拿出事先准备好的代码，让应聘者分析代码的结果。

    ```cpp
    #include <iostream>

    class A{

    private:
        int value;
        
    public:
        A(int n){
        
            value = n;
        }
        
        A(A other){
        
            value = other.value;
        }
        
        void Print(){
        
            std::cout<<value<<std::endl;
        }
    };

    int main(int argc, const char * argv[]) {

        A a = 10;
        A b = a;
        b.Print();
        
        return 0;
    }
    ```

    选择A.编译错误       B.编译成功，执行时程序崩溃             C.编译执行正常。输出10

    答案是A。编译出错。

    在上述代码中，复制构造函数A(A other)传入的參数是A的一个实例。因为是传值參数，我们把形參拷贝到实參会调用复制构造函数。因此假设同意复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无休止恶递归调用从而导致栈溢出。因此C++标准不同意复制构造函数传值參数。

    在Visual Studio和GCC中，都会编译出错。要解决问题，就是把传值參数改动为常量引用。

    代码例如以下：

    ```cpp
    A(A const &other)
    {
        value = other.value;
    }
    ```

3. 写代码定义一个类型或者实现一个成员函数。

推荐：

* 《Effective C++》
* 《C++ Primer》
* 《深度探索C++对象模型》
* 《The C++ Programming Language》

## 剑指offer面试题1--赋值运算符函数

[面试题1：赋值运算符函数](../../src/01_AssignmentOperator/AssignmentOperator.cpp)：如下为类型CMyString的声明，请为该类型添加赋值运算符函数(拷贝赋值运算符)。

```cpp
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);
      
private:
    char* m_pData;
};
```

解决该问题应该首先注意下面几点：

1. 是否把返回值的类型声明为该类型的引用。并在函数结束前返回实例自身的引用（即*this）。只有返回一个引用，才可以允许连续赋值。否则如果函数的返回值是void，应用该赋值对象符将不能做连续赋值。如果有三个CMyString对象，str1,str2,str3,在程序中语句`str1=str2=str3`将不能通过编译。

2. 是否把传入的參数的类型声明为`常量引用`。假设传入的參数不是引用而是实例，那么从形參到实參会调用一次复制构造函数。把參数声明为引用能够避免这种无谓的消耗，能提高代码的效率。同一时候，我们在赋值运算符函数内不会改变传入的实例的状态。因此应该为传入的引用參数加上constkeyword。

3. 是否释放实例自身已有的内存。假设我们忘记在分配新内存之前释放自身已有的空间，程序将出现`内存泄露`。

4. 是否推断传入的參数和当前的实例`(*this)`是不是同一个实例。假设是同一个，则不进行赋值操作，直接返回。假设事先不推断就进行赋值，那么在释放实例自身的内存的时候就会导致严重的问题：当`*this`和传入的參数是同一个实例时，那么一旦释放了自身的内存。传入的參数的内存也同一时候被释放了，因此再也找不到须要赋值的内容了。

### 经典的解法，适用于初级程序员

```cpp
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this == &str)
        return *this;

    delete []m_pData;
    m_pData = nullptr;

    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
```

适用于应届毕业生或C++初级程序员，对于高级程序员需要更高的要求。

* 可能导致程序崩溃：再分配内存前先用delete释放了实例m_pData的内存，此时内存不足则会导致new char 抛出异常，则m_pData将会是一个空指针，非常荣誉导致成或许崩溃。

### 考虑异常安全的解法，高级程序员必备

```cpp
// 考虑异常安全的解法，高级程序员必备
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this != &str)
    {
        CMyString strTemp(str);

        char* pTemp = strTemp.m_pData;
        strTemp.m_pData = m_pData;
        m_pData = pTemp;
    }

    return *this;
}
```

实现异常安全性：

* 先用new分配运算符，再用delete释放已有的内容。
* 先创建一个临时变量，再交换临时实例和原来的实例。

### 为什么要先释放原来对象原有的内存资源呢？

1. 内存泄漏：成员有指针，如果不释放原对象的内存，当新的数据被拷贝过来后，原内存将无法通过任何指针访问，从而变成无法释放的“悬挂”内存，造成内存泄漏。

2. 资源浪费：每次赋值都只是简单地复制数据而不清理旧数据，会使得每次赋值操作都增加新的内存消耗，即使这些内存很快变得不再可访问。

3. 潜在的逻辑错误：如果对象持有指向某种资源（不仅仅是内存，也可能是文件句柄、网络连接等）的指针，不正确地管理这些资源的生命周期可能会导致程序行为异常或崩溃。

因此，在执行赋值操作前先释放原有的内存资源是一种“深拷贝”的做法，确保了每个对象独立拥有其数据的副本，避免了上述问题，同时也使得对象的状态保持一致性和可预测性。这是面向对象编程中管理资源、确保对象完整性和健壮性的重要原则。

## 剑指offer面试题2--实现Singleton模式

[面试题2：实现Singleton模式](../../src/02_Singleton/Singleton.cpp):设计一个类，我们只能生成该类的一个实例。

* 对于C++而言，没有静态构造函数，因此只能使用局部静态变量。
* 双检锁（Double-Checked Locking, DCL）的版本，可能存在`reorder`问题。C++11后引入原子操作可以有效解决双检锁的问题。

## 剑指offer面试题3--数组中的重复数字

### 题目一：找出数组中重复的数字

[面试题3：找出数组中重复的数字](../../src/03_01_DuplicationInArray/FindDuplication.cpp)：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2或者3。

#### 最简单的方法--排序后相邻元素两两比较

先对数组排序，如果有重复元素排序后将会相邻。然后相邻元素两两比较，有相等的情况就找到了重复数字。排序一个长度为n的数组时间复杂度为O(nlogn)。

时间复杂度：O(nlogn)

#### 使用哈希表

将数组中的每个元素都加入哈希表

时间复杂度：O(n)
空间复杂度：O(n)

#### 利用题干信息——长度为n的数组里的所有数字都在0到n-1的范围内

上面的实现对于任意数组都是通用的。**我们要善于抓住题干的已知信息**，比如题目中明确说明了长度为n的数组里面的数字全是[0, n-1]之间的。从这句话能获得什么信息呢？如果将数组排好序，那么数组每一个位置都有numbers[i] = i，如果有重复元素，说明[0, n-1]中某些数字空缺了，某些数字有多个。那么必然有某个j !=i的numbers[j] == numbers[i]，如果找到满足上述条件的数字，就找到了重复数字。

* 如果值i没有在正确的位置（满足numbers[i] == i），通过交换两个元素，将值i放到正确的位置。这个过程可以看成是排序。
* 当numbers[i] != i，若令numbers[i] = j，显然j != i；如果此时numbers[j] == numbers[i]说明在与i不同的位置j找到重复元素。否则重复上一步。

[面试题3：找出数组中重复的数字 C++实现](../../src/03_01_DuplicationInArray/FindDuplication.cpp)

代码中尽管有一个两重循环，但是每个数字只需交换一两次就能被放在正确的位置上，因此总的时间复杂度为O(n)。而且所有操作都在原数组上进行，没有引入额外的空间，空间复杂度为O(1)。

* 修改了原数组
* 时间复杂度为O(n)
* 空间复杂度为O(1)

### 题目二：不修改数组找出重复的数字

[题目二：不修改数组找出重复的数字](../../src/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp)：在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。

#### 创建辅助数组进行计算

创建一个长度为N+1的辅助数组，然后逐一把原数组的每个数字复制到辅助数组。如果原数组中被复制的数字是m，则把它复制到辅助数组中位置为m的位置，这样很容易发现哪个数字重复了。

时间复杂度：O(n)
空间复杂度：O(n)

#### 二分查找

**解题思路：**

1. 我们把从 1\~n 的数字从中间的数字 m 分为两部分，前面一半为 1\~m,后面一半为 m+1\~n。
2. 如果 1\~m 的数字的数目超过 m ,那么这一半的区间里一定包含重复的数字;否则，另一半 m+1\~n 的区间里一定包含重复的数字。
3. 我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。

[题目二：不修改数组找出重复的数字 C++实现](../../src/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp)

