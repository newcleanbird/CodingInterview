# 第2章-面试需要的基础知识

## 编程语言

* 由于本人目前主要使用C++，因此本书以C++形式展现。

### C++

语言面试有三种类型：

1. 直接询问应聘者对于C++概念的理解：
    * C++中，有哪四个与类型转换相关的关键字？这些关键字各有什么特点，应该在什么场合下使用？
    * 定义一个空的类型，里面没有任何成员变量和成员函数对该类型求sizeof，得到的结果是什么？为什么不是0？
      * 答案是1。空类型的实例中不包括不论什么信息，本来求sizeof应该是0，可是当我们声明该类型实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。
      * 至于占用多少内存。由编译器决定。
      * Visual Studio中每一个空类型的实例占用1字节的空间。
    * 如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof，得到的结果是多少？
      * 答案还是1。调用构造函数和析构函数仅仅须要知道函数的地址就可以，而这些函数的地址仅仅与类型相关。而与类型的实例无关，编译器也不会由于这两个函数而在实例内加入不论什么额外的信息。
    * 如果把析构函数标记为虚函数呢？
      * C++编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每个实例中加入一个指向虚函数表的指针，在32位的机器上，一个指针占4字节的空间。因此求sizeof得到4，假设是64位的机器，一个指针占8字节的空间。因此求sizeof得到8.

2. 面试官拿出事先准备好的代码，让应聘者分析代码的结果。

    ```cpp
    #include <iostream>

    class A{

    private:
        int value;
        
    public:
        A(int n){
        
            value = n;
        }
        
        A(A other){
        
            value = other.value;
        }
        
        void Print(){
        
            std::cout<<value<<std::endl;
        }
    };

    int main(int argc, const char * argv[]) {

        A a = 10;
        A b = a;
        b.Print();
        
        return 0;
    }
    ```

    选择A.编译错误       B.编译成功，执行时程序崩溃             C.编译执行正常。输出10

    答案是A。编译出错。

    在上述代码中，复制构造函数A(A other)传入的參数是A的一个实例。因为是传值參数，我们把形參拷贝到实參会调用复制构造函数。因此假设同意复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成永无休止恶递归调用从而导致栈溢出。因此C++标准不同意复制构造函数传值參数。

    在Visual Studio和GCC中，都会编译出错。要解决问题，就是把传值參数改动为常量引用。

    代码例如以下：

    ```cpp
    A(A const &other)
    {
        value = other.value;
    }
    ```

3. 写代码定义一个类型或者实现一个成员函数。

推荐：

* 《Effective C++》
* 《C++ Primer》
* 《深度探索C++对象模型》
* 《The C++ Programming Language》

## 剑指offer面试题1--赋值运算符函数

题目描述：如下为类型CMyString的声明，请为该类型添加赋值运算符函数(拷贝赋值运算符)。

```cpp
class CMyString
{
public:
    CMyString(char* pData = nullptr);
    CMyString(const CMyString& str);
    ~CMyString(void);
      
private:
    char* m_pData;
};
```

[面试题1：赋值运算符函数 c++实现](../../src/01_AssignmentOperator/AssignmentOperator.cpp)

解决该问题应该首先注意下面几点：

1. 是否把返回值的类型声明为该类型的引用。并在函数结束前返回实例自身的引用（即*this）。只有返回一个引用，才可以允许连续赋值。否则如果函数的返回值是void，应用该赋值对象符将不能做连续赋值。如果有三个CMyString对象，str1,str2,str3,在程序中语句`str1=str2=str3`将不能通过编译。

2. 是否把传入的參数的类型声明为`常量引用`。假设传入的參数不是引用而是实例，那么从形參到实參会调用一次复制构造函数。把參数声明为引用能够避免这种无谓的消耗，能提高代码的效率。同一时候，我们在赋值运算符函数内不会改变传入的实例的状态。因此应该为传入的引用參数加上constkeyword。

3. 是否释放实例自身已有的内存。假设我们忘记在分配新内存之前释放自身已有的空间，程序将出现`内存泄露`。

4. 是否推断传入的參数和当前的实例`(*this)`是不是同一个实例。假设是同一个，则不进行赋值操作，直接返回。假设事先不推断就进行赋值，那么在释放实例自身的内存的时候就会导致严重的问题：当`*this`和传入的參数是同一个实例时，那么一旦释放了自身的内存。传入的參数的内存也同一时候被释放了，因此再也找不到须要赋值的内容了。

### 经典的解法，适用于初级程序员

```cpp
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this == &str)
        return *this;

    delete []m_pData;
    m_pData = nullptr;

    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pData, str.m_pData);

    return *this;
}
```

适用于应届毕业生或C++初级程序员，对于高级程序员需要更高的要求。

* 可能导致程序崩溃：再分配内存前先用delete释放了实例m_pData的内存，此时内存不足则会导致new char 抛出异常，则m_pData将会是一个空指针，非常荣誉导致成或许崩溃。

### 考虑异常安全的解法，高级程序员必备

```cpp
// 考虑异常安全的解法，高级程序员必备
CMyString& CMyString::operator = (const CMyString& str)
{
    if(this != &str)
    {
        CMyString strTemp(str);

        char* pTemp = strTemp.m_pData;
        strTemp.m_pData = m_pData;
        m_pData = pTemp;
    }

    return *this;
}
```

实现异常安全性：

* 先用new分配运算符，再用delete释放已有的内容。
* 先创建一个临时变量，再交换临时实例和原来的实例。

### 为什么要先释放原来对象原有的内存资源呢？

1. 内存泄漏：成员有指针，如果不释放原对象的内存，当新的数据被拷贝过来后，原内存将无法通过任何指针访问，从而变成无法释放的“悬挂”内存，造成内存泄漏。

2. 资源浪费：每次赋值都只是简单地复制数据而不清理旧数据，会使得每次赋值操作都增加新的内存消耗，即使这些内存很快变得不再可访问。

3. 潜在的逻辑错误：如果对象持有指向某种资源（不仅仅是内存，也可能是文件句柄、网络连接等）的指针，不正确地管理这些资源的生命周期可能会导致程序行为异常或崩溃。

因此，在执行赋值操作前先释放原有的内存资源是一种“深拷贝”的做法，确保了每个对象独立拥有其数据的副本，避免了上述问题，同时也使得对象的状态保持一致性和可预测性。这是面向对象编程中管理资源、确保对象完整性和健壮性的重要原则。

### 启示

1. 明确定义：如果类中没有显式定义复制构造函数，编译器会自动生成一个默认的复制构造函数，该构造函数执行逐个成员的浅复制。对于含有指针成员或动态分配内存的类，这可能导致资源重复释放或悬空指针问题。因此，当类中有指针或动态分配的资源时，应显式定义复制构造函数以执行深复制。
2. 深复制与浅复制：确保复制构造函数执行深复制，即不仅复制指针成员本身，还要复制指针所指向的数据。这意味着如果类中有指针成员指向堆上的数据，复制构造函数应该为新对象分配新的内存，并复制原来数据的内容。
3. 资源管理：如果类负责管理资源（如文件句柄、网络连接等），复制构造函数需要考虑资源的正确复制或共享策略，避免资源泄露或不当使用。
4. 自引用问题：当类的成员是指向自身类型的指针或引用时，需要特别小心处理自复制的情况，避免无限递归或循环引用的问题。
5. 使用成员初始化列表：为了效率和正确性，建议在复制构造函数的初始化列表中初始化成员，特别是对于非基本类型的成员。
6. 构造函数委托：C++11起，如果类中已有其他构造函数完成了大部分初始化工作，复制构造函数可以通过委托构造（使用:语法）来调用它们，以减少代码重复。
7. 异常安全：复制构造函数应设计为异常安全的，即在发生异常时，能够保持对象的不变性和资源的正确状态。
8. 复制省略优化（C++11起）：了解并利用C++编译器的复制省略和移动语义，这可以在某些情况下自动优化复制操作，提高效率。

## 剑指offer面试题2--实现Singleton模式

题目描述：设计一个类，我们只能生成该类的一个实例。

* 对于C++而言，没有静态构造函数，因此只能使用局部静态变量。
* 双检锁（Double-Checked Locking, DCL）的版本，可能存在`reorder`问题。C++11后引入原子操作可以有效解决双检锁的问题。

本题原版是介绍C#的单例模式，因此此处给出C#版本：
[面试题2：实现Singleton模式 C#实现](../../src/02_Singleton/Program.cs)

此处我结合题目情况，给出C++版本：
[面试题2：实现Singleton模式 C++实现](../../src/02_Singleton/Singleton.cpp)

### 启示

1. 深入理解不同语言的特性，同一种设计模式/设计方法使用不同的语言实现时，受特性影响，可能实现会有差距，甚至有的方案就行不通。
2. 深入理解并学习设计模式，使之灵活、正确应用于日常开发中。
3. “双检锁”是多线程语言中的普遍操作，也都会面临双检锁reorder问题。需要使用原子操作或具体语言特性解决。

## 剑指offer面试题3--数组中的重复数字

### 题目一：找出数组中重复的数字

题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2或者3。

#### 最简单的方法--排序后相邻元素两两比较

先对数组排序，如果有重复元素排序后将会相邻。然后相邻元素两两比较，有相等的情况就找到了重复数字。排序一个长度为n的数组时间复杂度为O(nlogn)。

时间复杂度：O(nlogn)

#### 使用哈希表

将数组中的每个元素都加入哈希表

时间复杂度：O(n)
空间复杂度：O(n)

#### 利用题干信息——长度为n的数组里的所有数字都在0到n-1的范围内

上面的实现对于任意数组都是通用的。**我们要善于抓住题干的已知信息**，比如题目中明确说明了长度为n的数组里面的数字全是[0, n-1]之间的。从这句话能获得什么信息呢？如果将数组排好序，那么数组每一个位置都有numbers[i] = i，如果有重复元素，说明[0, n-1]中某些数字空缺了，某些数字有多个。那么必然有某个j !=i的numbers[j] == numbers[i]，如果找到满足上述条件的数字，就找到了重复数字。

* 如果值i没有在正确的位置（满足numbers[i] == i），通过交换两个元素，将值i放到正确的位置。这个过程可以看成是排序。
* 当numbers[i] != i，若令numbers[i] = j，显然j != i；如果此时numbers[j] == numbers[i]说明在与i不同的位置j找到重复元素。否则重复上一步。

[面试题3：找出数组中重复的数字 C++实现](../../src/03_01_DuplicationInArray/FindDuplication.cpp)

[面试题3：找出数组中重复的数字 Java实现](../../src/03_01_DuplicationInArray/FindDuplicate.java)

代码中尽管有一个两重循环，但是每个数字只需交换一两次就能被放在正确的位置上，因此总的时间复杂度为O(n)。而且所有操作都在原数组上进行，没有引入额外的空间，空间复杂度为O(1)。

* 修改了原数组
* 时间复杂度为O(n)
* 空间复杂度为O(1)

### 题目二：不修改数组找出重复的数字

题目描述：
在一个长度为n+1的数组里的所有数字都在1到n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或者3。

#### 创建辅助数组进行计算

创建一个长度为N+1的辅助数组，然后逐一把原数组的每个数字复制到辅助数组。如果原数组中被复制的数字是m，则把它复制到辅助数组中位置为m的位置，这样很容易发现哪个数字重复了。

时间复杂度：O(n)
空间复杂度：O(n)

#### 二分查找

**解题思路：**

1. 我们把从 1\~n 的数字从中间的数字 m 分为两部分，前面一半为 1\~m,后面一半为 m+1\~n。
2. 如果 1\~m 的数字的数目超过 m ,那么这一半的区间里一定包含重复的数字;否则，另一半 m+1\~n 的区间里一定包含重复的数字。
3. 我们可以继续把包含重复数字的区间一分为二，直到找到一个重复的数字。

[题目二：不修改数组找出重复的数字 C++实现](../../src/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp)

### 启示

1. 拿到题目后，仔细查看问题的描述和细节问题。比如本题和变题的“不可修改原数组”，会直接导致使用不同的思路解题。
2. 与面试官深入沟通，挖掘需求，给出复合预期的解决方案。

## 剑指offer面试题4--二维数组中的查找

题目描述：
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

根据题目，一个满足要求的二维数组长下面这样。

```cpp
1 2 8 9
2 4 9 12
4 7 10 13
6 8 11 15
```

### 暴力搜索

思路：直接遍历整个二维数组，实现搜索。肯定不满足题意，且时间复杂度高。

时间复杂度：O(n^2)
空间复杂度：O(1)

### 对每一行进行二分查找

思路：每一行的一维数组已经有序，所以使用二分查找在每一行中查找，一旦找到立即返回。对于一个M*N的二维数组，一次二分查找的时间复杂度为O(lg N), M行就是O(Mlg N)。根据上面的表述已经可以很轻松地写出代码了。

```cpp
#include <vector>

class FindIn2DArray {
public:
    /**
     * 我想到的做法，对每一行的一维数组作二分查找.
     * 如果矩阵是M*N的，一次二分查找是O(lg N), M行就是O(Mlg N)
     *
     * @param target 要查找的数
     * @param array  二维数组
     * @return true如果在数组中找到target
     */
    bool Find2(int target, const std::vector<std::vector<int>>& array) {
        if (!array.empty()) {
            for (const auto& row : array) {
                int high = row.size() - 1;
                int low = 0;
                while (low <= high) {
                    int mid = low + (high - low) / 2;
                    if (target > row[mid]) {
                        low = mid + 1;
                    } else if (target < row[mid]) {
                        high = mid - 1;
                    } else {
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
```

代码还可以优化，根据这个二维数组的特点，任意一个位置其右边的所有元素和下边的所有元素都是大于它的。所以当我们按照从上到下的顺序遍历每一行的一维数组时，如果某次有

```cpp
else if (target < array[i][mid]) 
  {high = mid - 1;}
```

那么以后的若干行，都不用再和mid之后的元素比较了。因为array[i][mid]处的元素和它下边、右边的值相比是最小的，这个最小的元素都大于target，下边的、右边的值不用比较也知道比target大。举个例子

```cpp
1 2 8 9 16
2 4 9 12 17
4 7 10 13 18
6 8 11 15 19
```

如果target是7，当在第一行中二分查找时候，target < array[i][mid] = 8 ,high被更新为1， 既然7 < 8，对于8的右边、下边所有元素都是大于7的，无需再比较。所以下次循环中数组应该缩小为

```cpp
2 4
4 7
6 8
```

最开始的想法中，每次循环都将high重新初始化。考虑上面的优化，我们当high的值被更新后，在后续的循环中不再重新被初始化即可。

```cpp
// 优化前
for (int i = 0; i < array.length; i++) {
    int high = array[i].length - 1;
    int low = 0;
}

// 优化后
int high = array[0].length - 1;
for (int i = 0; i < array.length; i++) {
   int low = 0;
}
```

由于是从上到下的顺序遍历每一行，所以优化操作不能用于low。（当然如果是从底向上遍历的顺序，只能优化low而不能优化high）

时间复杂度：O(nlogn)
空间复杂度：O(1)

### 和右上角/左下角元素比较不断缩小范围

上面二分查找对high的优化是个很好的启发，如果我们将target和矩阵中的某一个数比较，如果`target > arr[i][j]`，那么`array[i][j]`的右边列所有元素、下边行的所有元素都有可能含有与target相等的数；同理如果`target < arr[i][j]`，那么`array[i][j]`的左边列所有元素、上边行的所有元素都有可能含有与target相等的数。这样问题就复杂了，编写代码时可能无从下手（到底选择往哪个方向移动？），和矩阵的左上角、右下角也是一个道理。

我们来看右上角/左下角，由于这两个位置对称，现只看右上角。**这个位置在一行中是最大的元素，在一列中是最小的元素。**根据这个特点，当右上角的值大于target，右上角元素那一列都是大于target的，所以可以直接剔除这一列；当右上角的值小于target，右上角元素那一行都是小于target的，所以可以直接剔除这一行；当右上角的值等于target说明找到，立即返回。就这样不断将范围一行一列地缩小...

* 右上角开始：当前遍历树大于目标数，则剔除所在列(j--);小于则剔除所在行(i++)
* 左下角开始：当前遍历树大于目标数，则剔除所在行(i--);小于则剔除所在列(j++)

[二维数组中的查找 c++实现](../../src/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp)

[二维数组中的查找 Java实现](../../src/04_FindInPartiallySortedMatrix/FindIn2DArray.java)

### 启示

1. 遇到类似的数组题、模拟题、树和图等题，试试通过具体的例子找出规律，进而找到解决问题的突破口。
2. 考虑问题要全面，突破传统的思维，比如本题一般都只想到从左上角开始试试，然后忽略掉了其他三个方向，导致发现复杂度很高or可行性很低，进而更换了思路，错过了正解思路。

## 剑指offer面试题5--替换空格

题目描述：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

### 使用C++库函数replace轻松解决

思路：由于使用Java语言，很容易想到使用库函数。遍历每个字符，如果遇到空格，就直接使用replace方法替换。

```cpp
#include <iostream>
#include <string>

std::string replaceSpaces(const std::string& input) {
    std::string output;
    for (char c : input) {
        if (c == ' ') {
            output.append("%20");
        } else {
            output.push_back(c);
        }
    }
    return output;
}

int main() {
    std::string originalStr = "We Are Happy.";
    std::string replacedStr = replaceSpaces(originalStr);
    std::cout << replacedStr << std::endl;  // 输出: We%20Are%20Happy.
    return 0;
}
```

### 时间复杂度为O(n^2)的解法，不足以拿到Offer

最直观的做法就是从头到尾扫描字符串，每次碰到字符的时候，都进行替换。

对每个空格字符，需要移动后面的O(n)个字符，对于含有n个空格字符的字符串，总的时间复杂度为O(n^2)。
空间复杂度为O(n)。

### 时间复杂度为O(n)的解法，搞定Offer就靠它了--从后往前扫描(双指针拷贝)

本着学习的态度（而不是完成任务），上面的方法虽然简洁，但封装过好的方法掩藏了算法的实现细节。现在我们自己来实现一种比较底层的方法。

按照一般思维，总习惯从左往右处理字符串。当遇见第一个空格时，其后的所有字符都需要右移两个位置；当遇见第二个空格时，其后的字符又要右移...因此很多字符被移动了不止一次。能不能减少移动的次数呢？**从前往后扫描要移动那么多次，不妨反过来从后往前扫描试试。**

* 先遍历一遍原字符串，统计空格字符的个数。
* 由于要将空格（一个字符）变成%20（三个字符），所以需要将原字符串增长2 * 空格数
* 设置两个指针，一个指针oldP指向原字符串的末尾；另一个指针newP指向增长后的新字符串末尾。不断将oldP处的字符移动到newP处，然后两个指针都要左移；如果oldP处字符是空格，就在newP处设置三个字符：按顺序分别是0、2、%，同样的两个指针相应的左移。

按照上面的算法流程，写出如下代码。

[替换空格 C++](../../src/05_ReplaceSpaces/ReplaceSpaces.cpp)

### 易错点

新字符串的长度是原始字符串长度+空格个数*2，而不是3，因为空格为1字节，%20为 3字节，比空格多2个字节。

`char * str`和`char str[]`相同点都是可以直接通过加法取得对应位置的元素，但是不同点是， char * str的值可以改变，而char str[]不能改变。如：

```cpp
char * str = "abc";
str++; //ok
char str1[] = “abc”;
str++; //error
```

char str[]的类型是const char *因此无法修改。
`char str[] = "abc"`中，`str`的长度是4，最后一个元素为`\0`。

```cpp
char str[4] = "abc"; //ok
char str[3] = "abc"; //error
```

### 启示

1. 在有库函数直接实现的情况下，为了极致的性能考虑，需要考虑不同实现的**时间和空间复杂度**，选择最优策略。同时注意"**开发效率**"也是很重要的指标。
2. 本题先计算需要的空间长度对数组扩容，再依次从后向前逐位复制的思路值得学习。对于合并数组的题目很适用。

### 相关题目

题目描述：有两个有序的数组A1和A2，A1末尾有足够空间容纳A2。实现一个函数将A2的所有数字插入到A1中，并且所有数字是有序的。

思路：因为空闲的空间在A1的末尾，所以从后往前比较两个A1和A2的数字，将更大的那个移动到A1的末尾，然后左移指针，继续比较两个数组中的数。当某个数组中的元素被取完了，就直接从另外一个数组取。

比如下面的例子

```cpp
A1 = [1, 2 ,4 ,7, 9, , , ...]
A2 = [3, 5, 8, 10, 12]
```

假设A1的长度为10，现暂时只有5个元素，这个长度刚好能装下A2。从后往前比较A1和A2：12比9大，将12移动到A1[9]中，然后9和10继续比较，10移动到A1[8]中，9和8比较9移动到A1[7]中，如此这般直到扫描完两个数组，所有数字也都有序了。

[MergeTwoSortedArray.java](../../src/05_ReplaceSpaces/MergeTwoSortedArray.java)

## 剑指offer面试题6--从尾到头打印链表

题目描述：输入一个链表的头节点，从尾到头打印链表每个节点的值。

### 使用栈

思路：此题可以使用链表逆序做，但是为了避免修改链表，我们将使别的方法来实现。思路非常简单，首先对链表进行遍历，将结果保存在一个栈中，再对栈中的结果依次出栈就行了。典型的后进先出，使用栈，顺序遍历一遍链表，依次将每个值入栈。得到的就是尾节点在前，头节点在后的列表。

[从尾到头打印链表 C++](../../src/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp)

[从尾到头打印链表 Java](../../src/06_PrintListInReversedOrder/FromTail2Head.java)

```cpp
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        if(!head) return vector<int>();

        //保存到栈内
        stack<ListNode *> temp;
        while(head)
        {
            temp.push(head);
            head = head->next;
        }

        vector<int> result;
        
        //出栈
        while(!temp.empty())
        {
            ListNode *h = temp.top();
            result.push_back(h->val);
            temp.pop();
        }

        return result;
    }
};
```

### 启示

1. 问清楚面试官题目需求，能否改变原链表。决定了你将采取什么方案去解决问题 。

## 剑指offer面试题7--重建二叉树

题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

### 递归

由中序遍历序列和前序或后序任一序列就能确定唯一的一棵二叉树，中序遍历序列是必须要的。

二叉树本来就是一种递归的结构，某个父结点，你可以说它拥有一个左子结点和一个右子结点，也可以说它拥有一棵以左子结点为根的左子树和一颗右子结点为根的右子树。因此二叉树的构建采用递归的方法是一种很自然的想法。

一棵树从上到下可以分解成了左子树、根结点、右子树，对于每一棵子树，又可以继续分解下去...一直到树底的叶子结点。相反，树的构建是从下到上的顺序，叶子结点可以看做最小的子树，这些子树的根结点成为其他结点的左右子结点，于是产生了更大的子树，这些子树继续成为上层结点的左右子结点....一直到根结点的做右子结点也确定下来。

关键是要找到每棵树的根结点，**前序遍历的第一个结点就是树的根结点；在中序遍历里找到这个结点，其左边的结点都是根结点的左子树，其右边的结点都是根结点的右子树。假如根结点左边有M个结点，那么在前序序列中，根结点后的M个结点也是属于根结点的左子树的。前序序列中余下的后面的结点自然属于根结点的右子树。**这样就可以把中序遍历的数组从根结点处分解成左右子树（对应的有两个子数组），然后递归地对这两个子数组执行同样的操作。现在重点是要在子数组中找到根结点——它依然是数组的第一个元素！

比如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}。前序序列可知根结点是1，于是从中序序列可知，{4, 7, 2}属于根结点1的左子树，有3个结点；{5, 3 ,8, 6}属于根结点1的右子树。回到前序序列，除开第一个根结点，其后3个结点{2, 4, 7}就是左子树，余下的{3, 5, 6 ,8}是右子树。按照这些关系可以精确地将数组分解成两个子数组，递归地对两个数组进行同样的操作即可。

实现：
[重建二叉树 C++](../../src/07_ConstructBinaryTree/ConstructBinaryTree.cpp)
[重建二叉树 C++](../../src/07_ConstructBinaryTree/ReConstructTree.java)

```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.empty() || vin.empty())
            return NULL;
        
        return ConstructBinaryTreeCore(pre, vin);
        
    }
    TreeNode *ConstructBinaryTreeCore(const vector<int> &pre, const vector<int> &vin)
    {
        int root_val =  pre[0];
        TreeNode *root = new TreeNode(root_val);

        if(pre.size() == 1)
            return root;
        
        int left_length = 0;
        for(auto var = vin.begin(); var != vin.end(); var++)
        {
            if(*var == root_val)
                break;
            left_length++;
        }
        int right_length = vin.size() - 1 - left_length;

        if(left_length)
            root->left = ConstructBinaryTreeCore(vector<int>(pre.begin() + 1, pre.begin() + 1 + left_length),
                                                 vector<int>(vin.begin(), vin.begin() + left_length));
        if(right_length)
            root->right = ConstructBinaryTreeCore(vector<int>(pre.begin() + 1 + left_length, pre.end()),
                                                  vector<int>(vin.begin() + 1 + left_length, vin.end()));

        return root;
    }
};
```

易错点：
pre.empty() 返回true代表pre为空，否则不为空

### 启示

1. 熟练掌握树的结构和使用。理解树的前序、中序、后序遍历。
2. 找规律，发现前序、中序、后序遍历之间的关系。
3. 理解递归，熟练使用递归遍历二叉树。

## 剑指offer面试题8--二叉树中序遍历的下一个结点

题目描述：
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

### 思路

要找出中序遍历的下一个结点，要分几种情况探讨。

* 如果当前结点的右子结点不为空，那么下一个结点就是以该右子结点为根的子树的最左子结点；
* 如果当前结点的右子结点为空，看它的父结点。此时分两种情况：
  * 如果父结点的右子结点就是当前结点，说明这个结点在中序遍历中已经被访问过了，需要继续往上看其父结点...直到父结点的左子结点是当前结点为止，该父结点就是下一个结点。
  * 如果在一直往上的过程中已经到达根结点，而根结点的父结点为null，这种情况说明当前结点已经是中序序列的最后一个结点了，不存在下一个结点，应该返回null。

[二叉树中序遍历的下一个结点](../../src/08_NextNodeInBinaryTrees/NextNodeInBinaryTrees.cpp)

### 启示

1. 熟悉二叉树的结构和中序遍历，在此基础上全面思考，充分考虑不同的情况。

## 剑指offer面试题9--两个栈实现队列

题目描述：
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

### 两个栈实现队列

解题思路：
刚开始两个栈都是空的，要进队列，可以将元素压入任何一个栈，不妨就压入stack1中，我们知道元素在栈中是后进先出的，因此要出列需要删除stack1最底部的元素，此时stack2派上用场了，将stack1的元素再压入stack2中，现在元素的排列变成了原来插入的顺序，要出列的元素到了栈顶，要完成出列操作就很方便了。若要继续出列，只要stack2不为空，只需继续从stack2中出栈即可，**因为stack2中的栈顶元素就是最先入列的元素。若stack2为空，就将stack1中的元素压入到stack2后，再弹出栈顶元素。**如果要入列，就直接压入stack1中。

总结一下就是：

* stack1专门用于进入队列
* stack2专门用于出队列
* 出列操作。stack2不为空就直接出列；为空就将stack1中所有元素压入stack2中，再弹出栈顶元素。

![两个栈实现队列 C++](../../src/09_QueueWithTwoStacks/QueueWithTwoStacks.cpp)

![两个栈实现队列 java](../../src/09_QueueWithTwoStacks/TwoStackImpQueue.java)

### 相关题目--两个队列实现栈

解题思路：
刚开始两个队列都为空，进栈时，可以进入任意一个队列。不妨默认进入Queue a。后续进栈时操作，哪个队列不为空（将看到，另外一个队列肯定为空）就进入该队列中。出栈操作，最后进入队列的要先出栈，而此时要出栈的元素在队列最后，但是队列只支持在队列头删除，因此将除了最后一个元素之外的所有元素都删除并复制一份到另一个队列Queue another，然后出列最后一个元素即可。此时Queue a成了空队列。之后每次出列操作都像上述以样：将不为空的队列中除最后一个元素的其余元素删除并复制到另一个空队列中，再删除原队列中唯一一个元素并弹出。每次出栈操作后，总有一个队列是空的。又因为进栈时也是进入不为空的那个队列，因此进出栈操作时总有一个队列是空的。

这两个队列不像上面的例子中有明确的分工，在两个队列实现栈的例子中，它们交替实现进栈或出栈的功能。

总结一下：

进栈，进入不为空的那个队列中
出栈，将不为空队列中除倒数最后一个元素外的其余元素移动到另一个空队列中，紧接着弹出原队列的最后一个元素。

[两个队列实现栈 java](../../src/09_QueueWithTwoStacks/TwoQueueImpStack.java)

### 启示

1. 两个栈可以模拟队列，两个队列可以模拟栈。
2. 那张纸模拟一遍思路即可。

## 剑指offer面试题10--斐波那契数列

题目描述:
现在要求输入一个整数n，请你输出斐波那契数列的第n项。
（从0开始，第0项为0）。

[斐波那契数列 C++](../../src/10_Fibonacci/Fibonacci.cpp)

[斐波那契数列 Java](../../src/10_Fibonacci/Fibonacci.java)

### 递归法

根据斐波那契数列的定义式子：`f(n) = f(n-1) + f(n-2)`即可得到递归公式。

```cpp
int fib2(int n) {
    if (n <= 0) 
    {
        return 0;
    }

    if (n == 1) {
        return 1;
    }

    return fib2(n-1) + fib(n-2);
}
```

* 递归法重复计算了很多节点，效率太低，用递归的时间复杂度是以n的指数的方式增长的。
* 因此面试官期待的方法肯定不是递归法。

### 迭代法

可以使用一个`Bottom-Up`的方法，`n=0`时，斐波那契数是`0`，`n=1`时，斐波那契数是`1`，`n=2`时是`0+1 = 2`，所以我们在计算第`n`个数的时候，将前`n-1`个斐波那契数组都计算出来，就可以得到结果了。

即：从底向上的方法：先得到f(0)、f(1)的值，然后根据这两个值计算序列后面的值。

```cpp

class Solution {
public:
    int fibIterative(int n) {
    if (n <= 1) return n;
    int a = 0, b = 1, sum;
    for (int i = 2; i <= n; ++i) {
        sum = a + b;
        a = b;
        b = sum;
    }
    return b;
}
};
```

### 动态规划法

代码和实现思路基本等同于迭代法。

```cpp
class Solution {
public:
    int Fibonacci(int n) {
        vector<int> dp(n+1);
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; i++)
        {
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[n];
    }
};
```

### 相关题目--青蛙跳台阶

题目描述：
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

#### 思路

到达1级台阶只有1种可能，到达2级台阶有2种可能；可记为f(1) = 1,f(2) = 2。要到达3级台阶，可以选择在1级台阶处起跳，也可以选择在2级台阶处起跳，所以只需求到达1级台阶的可能情况 + 到达2级台阶的可能情况，即f(3) = f(2) +f(1)

同理到达n级台阶，可以在n-1级台阶起跳，也可在n-2级台阶起跳，f(n) = f(n-2)+f(n-1)

可以完美转化为斐波那契数列。

```cpp
public class JumpFloor 
{
public:
    /**
     * @param target 要到达的第n级台阶
     * @return 到达n级台阶总共的跳法可能
     */
    int jumpFloor(int target) {
        if (target <= 0) {
            return 0;
        }
        if (target == 1) {
            return 1;
        }

        int a = 1;
        int b = 2;
        while (target > 1) {
            b = a + b;
            a = b - a;
            target--;
        }
        return a;
    }
}
```

* 本题是经典的"动态规划"类题目

### 相关题目--变态跳台阶 / 青蛙跳n级台阶

题目描述:
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

* 注意和上题的区别。

解题思路:
此题和青蛙跳的解题思路很相似。首先，我们分析对于第n个台阶，我们第一步有几种条法。很明显，我们第一步有n种跳法。 第一步跳1个台阶，2个台阶，3个台阶，。。。。。一直到n个台阶。对于每一种条法，我们可以得到如下的分析：
`f(n) = f(n - 1) + f(n - 2) + ..... + f(2) + f(1)`
其中`f(n - 2) + ..... + f(2) + f(1)`等于`f(n-1)`。则上式可以化简为：
`f(n) = 2 * f(n - 1)`
所以，f(n)是一个公比为2的等比数列

```cpp
class Solution {
public:
    int jumpFloorII(int number) {
        if(number == 1)
            return 1;
        if(number == 2)
            return 2;
        
        int number2 = 2;

        int result;
        for(int i = 3; i <= number; i++)
        {
            result = number2 * 2;
            number2 = result;
        }
        return result;
    }
};
```

### 相关题目--矩形覆盖问题

题目描述：
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

思路：
这个问题本质还是斐波那契数列...
覆盖2*n的矩形的方法记为f(n)。

* 当最后一步是竖着放时候，说明前一步已经覆盖了`2*(n-1)`，记为`f(n - 1)`
* 当最后一步是横着放的时候，倒数第二次也必然是横着放的。这个状态已经覆盖了`2* (n-2)`，记为`f(n - 2)`
因为最后一步只有横竖放两种可能，所以将上述两种方法可能性加起来即可。

覆盖`2*1`的矩形只有1种方法，覆盖`2*2`的矩形有横竖`2`种方法。于是`f(1) = 1`, `f(2) = 2`

这和能跳1级也能跳2级的青蛙是一样的。代码直接copy过来就行！

### 启示

1. 学习`一题多解`，拓展思路。学习`多题一解`，将问题转化和抽象为同一个模型。
2. `递归法`是基于问题分解的基本思想，将复杂问题分解为相似的子问题，直到达到简单的基本情况。通过函数自我调用来解决问题，通常基于问题可以分解为更小规模的相似子问题的特性。递归代码往往简洁易懂，但可能会导致栈溢出和重复计算。
   * 特点：递归通过函数自我调用来解决问题，通常基于问题可以分解为更小规模的相似子问题的特性。递归代码往往简洁易懂，但可能会导致栈溢出和重复计算。
   * 适用条件：适用于具有自然递归结构的问题，如树形结构的遍历（如二叉树）、分治策略（如快速排序、归并排序）和部分动态规划问题的基础情况。
   * 注意：递归必须要有一个退出的条件!
3. `迭代法`:迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，跟迭代法相对应的是直接法(或者称为一次解法)，即一次性解决问题。
   * 特点：迭代通常使用循环来逐步逼近问题的解，相对于递归，它更节省内存，避免了栈溢出的风险。但有时代码可读性可能不如递归。
   * 适用条件：几乎任何可以用递归解决的问题都可以转换为迭代法，特别适合那些递归深度大或重复计算多的问题，如斐波那契数列计算、广度优先搜索等。
4. `动态规划（DP）`主要用于求解最优化问题，通过填表的方式来避免子问题的重复计算，它的基础也是分解问题为子问题，但重点在于利用重叠子问题和最优子结构。
   * 特点：动态规划通过解决相互重叠的子问题来避免重复计算，通常使用表格来存储中间结果。它强调最优子结构和重叠子问题。
   * 适用条件：适用于有重叠子问题和最优子结构的问题，如背包问题、最短路径问题、编辑距离等。当问题可以通过定义状态和状态转移方程来描述时，使用动态规划最为高效。
5. `回溯法`则是一种通过试错来寻找所有（或某种）解的方法，适用于解决约束满足问题，通过探索决策树并剪枝来减少搜索空间。
   * 特点：回溯是一种通过试错寻找所有（或一部分）解的方法，采用深度优先搜索策略，并在发现当前路径无法得到解时回溯。通常结合剪枝策略来减少搜索空间。
   * 适用条件：适用于求解约束满足问题，如八皇后问题、图的着色问题、组合总和问题等。当解空间较大且需要探索多种可能性时，回溯法是非常有效的。
6. 迭代和递归的关系和区别
   * 从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到变量新值得编程思想。简单地说，递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环。
7. `递归转动态规划`：
   * 当递归问题中存在大量的重复子问题，且具有最优子结构时，可以考虑转换为动态规划。通过建立一个表（数组或矩阵）来存储子问题的解，避免重复计算，从而将时间复杂度从指数级降低到多项式级。例如，斐波那契数列、背包问题等经典问题，自然适合用动态规划来优化递归解法。
8. `递归转回溯法`：
   * 当递归问题涉及在可能的解决方案空间中搜索，且需要考虑多种选择，每种选择又会引出更多的选择时，可能更适合采用回溯法。回溯法通过逐层深入决策树，当发现当前路径不可能得到可行解时及时回溯，避免无效搜索。例如，八皇后问题、图的着色问题等，更适合使用回溯法。

### 易错点

* 注意斐波那契数组是前两个数的和，不是第i个数相加。
* 需要预设斐波那契数列的前两个数
  * f(0) = 0
  * f(1) = 1

## 剑指offer面试题11--旋转数组中的最小数字

题目描述:
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转， 输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

* 题目给出的是非递减排序数组，所以不是严格递增的，可能有相同元素的情况。

解题思路:
这道题的本质就是查找一个数组中的最小值，属于查找问题，但是从数组中第一个元素开始`顺序遍历`，看哪个元素最小显然不合适，`时间复杂度为O(n)`。因此可以考虑一些`O(logn)`的算法，比如`二分查找`。但是二分查找一般来说是用于已经排序 过的数组，但是仔细观察后可以发现，数组旋转过后，整个数组可以分成两个部分，数组最小值左边的部分大于最小值右边 的部分。使用二分法进行查找的时候，如果中间值大于数组中第一个数，则说明最小值在后半部分，如果中间值小于数组中 第一个值，则说明最小值在数组的左半部分。之后重复查找步骤，最后的结束条件就是当数组只有2个元素的时候，最小值 为第二个元素。因为第一个指针low将指向大于mid的元素的数组，而high将指向大于mid的元素的数组。最后不会出现low 和high都指向同一个元素的情况。

### 顺序遍历

两个子数组都是递增的，只有在两个子数组的分界线处，才会有前一个字符大于后一个字符。时间复杂度为O(n)

```cpp
int minNumberInRotateArray(vector<int> &array) {
    if (array.length == 0) {
        return 0;
    }

    for (int i = 0;i < array.length - 1;i++) {
        if (array[i] > array[i + 1]) {
            return array[i + 1];
        }
    }
    return array[0];
}
```

### 二分查找

由于有序数组旋转后，被分成了两个有序的子数组，因此可以用二分查找，且左半数组的值全大于等于右半数组的值。我们要找的最小元素恰好是右半数组的第一个元素，或者说左半数组末尾后一个元素。

和`二分查找`一样，一个指针`low`指向数组首元素，一个`high`指向尾元素。还有一个指针`mid`，这里注意：mid不是要和哪个特定的值比较来缩小范围，根据旋转数组的特点，我们始终将mid和high处的值比较。分三种情况:

* array[mid] > array[high];此时mid一定还处于左半数组中，而要找的最小值在右半数组中，最小值肯定在mid的右边，所以可以直接将low移动到mid的下一个位置，即low = mid + 1。举个例子{3, 4, 5, 1, 2}，mid处的5比high处的2大，直接更新low = 3，数组被缩小到{1, 2}
* rray[mid] < array[high];此时mid一定处于右半数组中，最小值可能在mid处也可能在mid的左边。所以high只能缩小到mid处，即high = low。举个例子{4, 5, 1, 2, 3}，mid处的1小于high处的3，只能将high移动到1处，数组缩小为{4, 5, 1}，如果像上面类似令high = mid - 1，最小值再这个例子中就被跳过了！
* array[mid] == array[high];此时无法分辨mid处于左半数组还是右半数组。比如{1, 0, 1, 1, 1}和{1, 1, 1, 0, 1}都是数组{0, 1, 1, 1, 1}的旋转数组。此时mid处和high处的值一样，若根据low缩小范围，对于{1, 0, 1, 1, 1}最小值将被跳过；如果根据high缩小范围，对于{1, 1, 1, 0, 1}最小值也会被跳过。此时的处理方法是暂时放弃二分查找，**既然mid处和high处值相同，那么让high--，让mid和high的前一个值继续比较。**如果mid和high处都是最小值，就算放弃了high最后还是会在mid处找到最小值。

**只要low < high(不含等于)，就不断重复上面过程，最后将范围缩小到只有一个元素后，low == high跳出循环。**其实low == high时候还进入循环，也没有错，此时只会造成high--，而我们返回的是array[low]，值不会影响，但是何必进行这次无意义的比较呢。

```cpp
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        //if move the first 0 elements to the end
        if(rotateArray.front() < rotateArray.back())
            return rotateArray.front();
        
        return searchMin(rotateArray);
    }
    int iterate_through(const vector<int> &arr)
    {
            int min = 0;
            for(auto x : arr)
            {
                if(x < min)
                    min = x;
            }
            return min;
    }
    int searchMin(vector<int> &arr)
    {
        int low = 0;
        int high = arr.size() - 1;
        int mid = (low + high) / 2;
        while(arr[low] >= arr[high])
        {
            if((high - low) == 1)
            {
                mid = high;
                break;
            }
            
            if(arr[low] == arr[high] && arr[high] == arr[mid])
            {
                return iterate_through(arr);
            }

            if(arr[low] > arr[mid])
            {
                high = mid;
                mid = (low + high) / 2;
            }
            else if(arr[high] < arr[mid])
            {
                low = mid;
                mid = (low + high) / 2;
            }
        }
        return arr[mid];
    }
};
```

时间复杂度为O(lg n)。

上面始终将`mid`和`high`比较，可不可以`mid`和`low`比较呢，可以但是和与high比较相比更麻烦。

试想如果最后范围缩小到剩下`{1, 2}`此时`array[low] == array[mid]`，如果low++就跳过最小元素了，此种情况可以写一个`min(int low, int high)`方法，直接返回`[low, high]`范围内的最小值。比起用`high`来和`mid`比较，麻烦了不少。

### 易错点
最不容易想到的点就是循环结束的条件，并不像原始的二分查找算法，low和high指针最终会指向同一个元素， 在这个题中，low和high永远无法指向同一个元素。也就是说，数组元素个数最少是2个。

对于 [0,1,1,1,1] -> [1,1,1,0,1]这种情况，low=mid-high，无法用二分查判断出mid在哪个部分，所以只能 逐个查找。

### 启示

1. 理解并掌握二分查找，以及二分查找的边界条件。(灵活掌握并不容易)。
2. 在思路方面，先确定最显而易见的方案的复杂度。然后再考虑优化方案。

## 剑指offer面试题12--矩阵中的路径

题目描述：

```cpp
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如下面矩阵

a b t g 
c f c s 
j d e h

包含一条字符串"bfce"的路径，但是矩阵中不包含"abfb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
```

这有点像图的`深度优先搜索`。除了矩阵边界，每个点都可以在4个方向上选择任意一个前进。当某一条路径失败后，需要回溯到上一次选择处，选择另一个方向再尝试。如果该处的方向都被尝试过了，继续回溯到上次选择处...每一次选择都会来到一个新的格子，在这个格子处又有若干个方向可选择，就这样不断前进、回溯、再前进，直到找到一条满足要求的路径为止；如果所有点都作为起点搜索一遍后还是没有找到满足要求的路径，说明在这个矩阵中不存在该条路径。

上面的描述，使用递归比较好理解。还有一点需要注意，由于路径上访问过的点不能进入第二次，所以需要一个`bool[] marked`标记那些当前路径上被访问过的点。

### 回溯法 / dfs

[矩阵中的路径 C++](../../src/12_StringPathInMatrix/StringPathInMatrix.cpp)

[矩阵中的路径 jAVA](../../src/12_StringPathInMatrix/PathIn2DArray.java)

```cpp
class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        for(int row = 0; row < rows; row++)
            for(int col = 0; col < cols; col++)
                if(found(matrix, row, col, str, rows, cols))
                    return true;
        
        return false;

    }
    bool found(char* m, int row, int col, char *str, int rows, int cols)
    {
        if(row < 0 || row > rows)
            return false;
        
        if(col < 0 || col > cols)
            return false;
        
        if(*str != *(m + row * cols + col))
            return false;
        
        if(*str == '\0')
            return true;
        
        if(*(m + row * cols + col) == '\0')
            return false;
        
        bool result;
        char temp = *(m + row * cols + col);
        *(m + row * cols + col) = '\0';

        result = found(m, row + 1, col, str + 1, rows, cols) ||
                 found(m, row - 1, col, str + 1, rows, cols) ||
                 found(m, row, col + 1, str + 1, rows, cols) ||
                 found(m, row, col - 1, str + 1, rows, cols);

        *(m + row * cols + col) = temp;

        return result;
    }
};
```

### 易错点

最不容易想到的点就是循环结束的条件，并不像原始的二分查找算法，low和high指针最终会指向同一个元素， 在这个题中，low和high永远无法指向同一个元素。也就是说，数组元素个数最少是2个。

对于 [0,1,1,1,1] -> [1,1,1,0,1]这种情况，low=mid-high，无法用二分查判断出mid在哪个部分，所以只能 逐个查找。

### 启示

1. 理解回溯法的本质：思想是深度遍历(dfs)，实现是递归的变体。算法本身效率相比较直接暴力搜索没有任何改善，但能解决暴力搜索无法解决的问题，是为了实现计算复杂的搜索算法。

## 剑指offer面试题13--机器人的运动范围

问题描述：
地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

解决思路：
此题和面试题12——矩阵中的路径有相似之处，依然是`回溯法`。每来到一个新的且满足条件的格子时，计数加1。除矩形的边界外，任意一个方格都有四个方向可以选择，选择任一方向后来到新的格子又可以选择四个方向，但是一个到达过的格子不能进入两次，因为这将导致对同一个格子的重复计数。也就是说，**一个格子一旦满足条件进入后，就被永久标记为“访问过”，一个满足条件的格子只能使计数值加1。**这是和面试题12有区别的地方（那个例子中是搜索路径，失败路径上的点要重新标记为“未访问”，因为另开辟的新路径需要探索这些点）。

这道题用通俗的话来讲就是：m行n列的所有方格中，有多少个满足行坐标和列坐标的数位之和小于等于门限值k的格子？

### 回溯法

![机器人的运动范围](../../src/13_RobotMove/RobotMove.cpp)

![机器人的运动范围](../../src/13_RobotMove/RobotMove.java

### 启示

1. 注意回溯算法的“剪枝”和“回收结果”

## 剑指offer面试题14--剪绳子

题目描述：
给你一根长度为n的绳子，把绳子剪成m段（m、n都是整数且m > 1, n > 1）,m段绳子的长度依然是整数，求m段绳子的长度乘积最大为多少？比如绳子长度为8，我们可以分成2段、3段、4段...8段，只有分成3段且长度分别是2、3、3时能得到最大乘积18

[剪绳子 C++实现](../../src/14_CuttingRope/CuttingRope.cpp)

### 动态规划版本

要求大问题的最优解，可以将大问题分解成小问题，分解的小问题也有最优解，因此将小问题的最优解组合起来就能得到大问题的最优解。若将f(n)定义为将长度为n的绳子分成若干段后的各段长度的最大乘积（最优解），在剪第一刀时有n-1种剪法，可选择在0 < i < n处下刀；如在i处下刀，分成长度为i的左半绳子和长度为n - i的右半绳子，对于这两根绳子，定义最优解为f(i)和f(n-i)，于是f(n) = max(f(i) * f(n-i))，即求出各种相乘可能中的最大值就是f(n)的最优解。这两根绳子又可以继续分下去，就这样从上到下的分下去，但是问题的解决得从下到上来。因为f(2)、f(3)的很好求：
* f(2) = 1，因为只能分成两半
* f(3) = 2，因为分成两段2*1 大于分成三段的1*1*1
* 然后根据这两个最优解求出f(4)、f(5)...直到f(n)，每个f(i)的确定是通过遍历所有可能的相乘情况，从中选出乘积最大者。

```java
public static int maxProductAfterCutting(int length) {
    // 长度为1时不满足题意，返回0
    if (length < 2) {
        return 0;
    }
    // f(2)
    if (length == 2) {
        return 1;
    }
    // f(3)
    if (length == 3) {
        return 2;
    }
    // 加1是因为需要访问到products[length]
    int[] products = new int[length + 1];
    // 下面这三个存的不是f(1)、f(2)、f(3)，只是单纯的长度而已
    products[1] = 1;
    products[2] = 2;
    products[3] = 3;
    // 从products[4]到products[length]放的是f(4)~f(n)的值
    for (int i = 4; i <= length; i++) {
        int max = 0;

        // 对所有相乘情况进行遍历求出f(i)的最优解
        for (int j = 1; j <= i / 2; j++) {
            int product = products[j] * products[i - j];
            if (product > max) {
                max = product;
            }
        }
        // 得到f(i)的最优解
        products[i] = max;
    }
    // 返回f(n)
    return products[length];
}
```

对于长度为2或者3的绳子，可以直接返回答案。之后f(4)~f(n)的值存放在了`products[4]~products[n]`中，注意product[1]~products[3]中存放的不是f(1)~f(3)，它们单纯地表示长度而已，作为求出`f(i)，4 <= i <= n`的辅助。最后得到的f(n)存放在`products[n]`中，直接返回即可。第二层中的for循环为了得到`f(i)`，遍历了所有可能的乘积情况，将最大乘积赋予`max`。`j <= i / 2`是为了避免重复的相乘情况，比如`i = 4`时，只有`2*2`和`1*3` 两种，`3*1`和`1*3`是同一种相乘情况，所以`j`只到`i / 2 = 2`即可枚举所有相乘情况。

### 贪婪算法

我们应用贪婪算法解决问题时，每一步都可以做出一个贪婪的选择。基于这个选择，我们确定能得到问题的最优解。为什么能得到最优解，还需要数学证明来保证。

这道题我们按照下面的做法就能得到最优解：如果绳子长度`n >= 5`，就不断分出长度为3的绳子，如果最后只剩下长度为`1`的绳子，退一步，将得到长度为4的绳子，然后将这长度为4的绳子分成`2*2`(这样分是因为`2*2`大于原来的`3*1`)；因此`n = 4`时不能分出长度为3的绳子,而`n = 2`，`n = 3`的最优解可直接返回。

基于此写出代码。

```cpp
public static int maxProductAfterCutting2(int length) {
    // 长度为1时不满足题意，返回0
    if (length < 2) {
        return 0;
    }
    // f(2)
    if (length == 2) {
        return 1;
    }
    // f(3)
    if (length == 3) {
        return 2;
    }
    // 统计能分出多少段长度为3的绳子
    int timesOf3 = length / 3;
    // 如果最有只剩下长度为1的绳子，需要退一步，得到长度为4的绳子，重新分成2*2的
    if (length - timesOf3 * 3 == 1) {
        timesOf3--;
    }
    // 统计能分出多少段长度为2的绳子
    // 到这步length - timesOf3 * 3的值只可能是0,2,4，所以timesOf2只可能是0, 1, 2
    int timesOf2 = (length - timesOf3 * 3) / 2;
    return (int) Math.pow(3, timesOf3) * (int) Math.pow(2, timesOf2);

}
```

### 启示

1. 动态规划的使用是基于递归式的分析后，做出的简化实现。
   1. 求最优解
   2. 整体问题的最优解依赖各个子问题的最优解
   3. 大问题分解成若干小问题，这些小问题之间有互相重叠的子问题。
2. 贪婪算法是局部最优解，需要数学论证局部最优是全局最优。
   1. 因此贪婪算法求出的结果可能不是最优解。

## 剑指offer面试题15--二进制中1的个数

题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

[二进制中1的个数 C++](../../src/15_NumberOf1InBinary/NumberOf1InBinary.cpp)

### "错误的"常规思路

容易想到的思路：该数的各位不断和1相与，然后将该数右移1位，直到所有位都比较过。

```cpp
public int numberOf1_2(int n) {
   int count = 0;

   while (n != 0) {
     if ((n & 1) == 1) {
       count++;
     }
     n = n >> 1;
   }
   return count;
}
```

注意！上面的代码是错误的！对于非负数来说没有问题，但是当传入负数的时候，由于>>是带符号的右移，对于负数来说高位会以1补位，n永远也不会等于9，因此会出现无限循环。

在Java中右移分两种，一种是上面那样带符号的右移，用>>表示，如果数是正数高位以0补位，如果是负数高位以1补位；还有就是无符号的右移，用>>>表示，不论正负数，统统高位以0补位。因此只需改动将上述程序的>>改成>>>即可通过。

在C++中，右移运算符（>>）的行为会根据操作数的类型（有符号或无符号）有所不同：

* 有符号右移（Signed Right Shift）：
  * 当应用于有符号整数（如int、long等）时，右移操作符执行的是算术右移。这意味着，最高有效位（即符号位）会被保留，而在左侧空出来的位将被符号位填充。对于正数，这等同于在高位插入0；而对于负数，由于最高位为1（表示负数），因此在移位后左侧也会填充1。这种移位方式保证了负数仍然被视为负数，尽管其绝对值可能会发生变化。
* 无符号右移（Unsigned Right Shift）：
  * 当应用于无符号整数（如unsigned int、unsigned long等）时，右移操作符执行的是逻辑右移。逻辑右移会在高位插入0，无论原数是正数还是负数（实际上，对于无符号类型而言，没有负数的概念）。这使得无符号右移非常适合用于纯粹的位操作，比如将一个数值除以2的幂次。

### 右移版本

```java
public int numberOf1_2(int n) 
{
    int count = 0;

    while (n != 0) 
    {
        if ((n & 1) == 1) 
        {
            count++;
        }
        n = n >>> 1;
    }
    return count;
}
```

### 左移版本

上面的第一个程序之所以会出现无限循环，是因为我们改变了被输入的数本身。换个角度，我们不改变输入的数，而是通过改变一个变量，那么不管是输入正负数都能得到正确答案。

所以用一个1和输入数的每一位相与，然后将这个1不断左移。

```cpp
public int numberOf1_1(int n) {
    int count = 0;
    int flag = 1;
    while (flag != 0) 
    {
        if ((n & flag)!= 0) 
        {
            count++;
        }
        // 每次改变的只是这个变量，输入的数始终没有被改变过
        flag = flag << 1;
    }
    return count;
}
```

### 更为巧妙的方法

要想出这样的方法，需要经过一定的分析。将任意数减去1,，有两种情况

* 该数二进制表示的最低位就是1，比如数7，二进制表示为111，此时直接减去1即可；
* 最低位不为1，假设从右往左出现的第一个1，位置为m。则该数减去1后，位置m处的1会变成0，m之后所有的0都会变成1。比如数12，二进制表示为1100，减去1，先找到从右往左数的第一个1，这个位置的1变成0，其后的两个0变成1，即变成了1011。此时，如果将减去1后得到的1011和原来的1100相与，得到1000，相当于是将最右边的那个1变成了0。
  
也就是说：**把一个整数减去1之后再与原来的整数做位与运算，得到的结果相当于将原整数的二进制表示中最右边的1变成0。**

基于这个推论，写出如下程序。

```cpp
public int numberOf1(int n) {
    int count = 0;
    // 只要数不为0，其二进制表示中至少含有一个1
    while (n != 0) {
        // 将最右边的1变成0
        n = (n-1) & n;
        // 每将一个1变成了0，就计数一次
        count++;
    }
    return count;
}
```

### 相关的题目

1. 写一个函数判断一个整数是不是2的正整数次方。

    ```cpp
    boolean isExponOf2(int n) {
        return numberOf1(n) == 1;
    }
    ```

2. 输入两个整数m和n，计算需要改变m的二进制表示中的几位才能得到n。比如10的二进制是1010，13的二进制是1101，则需要改变3次。

    ```cpp
    int bitNumNeedsToBeChanged(int m, int n) {
        return numberOf1(m ^ n);
    }
    ```

### 启示

1. 位运算分为左移、有符号右移、无符号右移
2. 左移 = ×2， 右移 = /2。使用右移代替除2
   1. 常用于二分查找
