# 第3章-高质量的代码

## 剑指offer面试题16--数值的整数次方

题目描述：
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

解题思路：
最简单直白的方式，就是exponent是多少，就乘上多少个base，就能得到正确的结果了。需要 注意的可能就是exponent为0或者为负数的时候该如何处理了。

[数值的整数次方 C++](../../src/16_Power/Power.cpp)

### 连乘

注意要考虑次幂为负数的情况。由于负次幂等于base的正次幂的倒数，所以取绝对值直接计算正次幂的情况就行，最后再根据exponent是否为负决定取不取倒数。当base为0时候，结果和次幂无关（都为0，假设0的非正数次幂都为0，因为它们在数学中并没有定义），所以把base == 0的情况单独抽出来直接返回。算法采用了连乘，时间复杂度是O(n)

```cpp
class Power {
public:
    /**
     * @param base     基数
     * @param exponent 次幂
     * @return base^exponent
     */
    double power_2(double base, int exponent) {
        if (base == 0) {
            return 0;
        }

        double result = 1.0;
        int positiveExponent = Math.abs(exponent);
        for (int i = 0; i < positiveExponent; i++) {
            result *= base;
        }
        return exponent < 0 ? 1 /result : result;
    }
}
```

有没有更快的方法呢？

### 快速幂

我们要求$a^n$，分n为奇数和偶数两种情况，如下

$a^n = a ^{n /2}  \times  a ^{n /2} $，n为偶数

$a^n = a ^{(n-1) /2}  \times  a ^{(n-1) /2} \times a $，n为奇数

假如要求$2^{32}$，按照上面连乘的思路，需要进行31次乘法；采用上面的公式，只需要5次：先求平方，然后求四次方、八次方、十六次方，最后三十二次方。将时间复杂度降到了O(lg n)。

```cpp
class Power {
public:
    /**
     * 非递归。推荐的做法，复杂度O(lg n)
     */
    double power(double base, int exponent) {
        if (base == 0) {
            return 0;
        }

        double result = 1.0;
        int positiveExponent = Math.abs(exponent);

        while (positiveExponent != 0) {
            // positiveExponent & 1这句是判断奇数的
            if ((positiveExponent & 1) == 1) {
                result *= base;
            }

            base *= base;
            // 右移1位等于除以2
            positiveExponent = positiveExponent >> 1;
        }

        return exponent < 0 ? 1 / result : result;
    }
private:
    /**
     * 和上面是同一个思路，递归版本。选择上一个非递归版本的
     */
    double powerUnsigned(double base, int exponent) {
        if (exponent == 0) {
            return 1;
        }
        if (exponent == 1) {
            return base;
        }

        double result = powerUnsigned(base, exponent >> 1);
        result *= result;
        if ((exponent & 1) == 1) {
            result *= base;
        }
        return result;
    }
public:
    public double power_1(double base, int exponent) {
        if (base == 0) {
            return 0;
        }
        int positiveExponent = Math.abs(exponent);
        double result = powerUnsigned(base, positiveExponent);
        return exponent < 0 ? 1 / result : result;
    }
}
```

上面给出了这个思路的两个实现，一个使用了递归，一个使用了非递归——一般来说非递归的实现更好。

非递归版本看上去和连乘的实现很像，只是循环里面的内容不一样。使用了`positiveExponent & 1`来判断一个正数是否为奇数：**一个正数和1相与，如果值等于1就可以说这个数是奇数，这是因为奇数的二进制表示，最低位一定是1**。这步操作相当于上述数学公式中，n为奇数的情况，此时需要多乘一个base。注意当n奇数时，次幂应该是$(n-1)/ 2$，但在Java的除法中，对于一个奇数n，有n / 2 == (n-1) /2，所以不管奇偶，统一右移一位（等同于除以2）。再注意一点，我们是先判断次幂是否为奇数后再对结果进行平方的，这个顺序不可交换——至于为什么可以随便举个例子模拟一下能不能得到正确的结果。

说到判断奇数的顺序，在递归版本中恰恰和非递归版本相反。递归版本中是**先进行平方操作后才判断次幂是否为奇数**。对于exponent等于0或1两种简单情况直接返回，这也是终止递归的条件。递归版本基本就是翻译上面的公式——一般来说递归版本的代码简洁易懂。

### 易错点
没有考虑指数为0或者负数的情况。

### 启示

1. 三种错误处理的方法
   1. 函数用返回值告知调用者是否出错。
   2. 当错误发生时设置一个全局变量。
   3. 异常
2. 在编码前要考虑单元测试
   1. 功能测试
   2. 边界测试
   3. 负面测试
3. 理解库函数的实现原理
4. 考虑问题要全面

## 剑指offer面试题17--打印从1到最大的n位十进制数

题目描述：
输入数字n，按顺序打印处1到最大的n位十进制数，比如输入3，则打印1~999之间的数

### 跳进面试官陷阱

这道题有陷阱，可能容易想到输入`4`就打印`19999`，输入`5`就打印`199999`...那我要是输入`100`呢？`int`型不能表示出来吧，甚至更大的值，即便是`long`型也不能表示出来。

这是一道**大数问题**，牵涉到大数问题我们可以将其转化为**字符串**表示。因为字符串任意长度都行。

1. 遇到大数问题，一般转换为字符串或者数组

### 在字符串上模拟数字加法的解法，绕过陷阱才能拿到offer

本题要求按照递增顺序打印出1~最大的n位十进制数，所以字符串的长度定也应该是n。首先将长度为n的字符串中每个字符初始化为0，比如n = 3时，字符串一开始为000。我们要做的只有两步：

* 模拟数字那样在字符串上做加法；
* 将字符串表达的数字打印出来，为了可读性需要忽略不必要的0；

[打印从1到最大的n位十进制数 C++](../../src/17_Print1ToMaxOfNDigits/Print1ToMaxOfNDigits.cpp)

[打印从1到最大的n位十进制数 Java](../../src/17_Print1ToMaxOfNDigits/PrintFrom1ToMaxOfNDigit.java)

### 把问题转换成数字排列的解法，递归让代码更简洁

n = 3时候我们需要打印的条目依次是

```cpp
001
002
003
004
...
009
010
011
012
...
099
100
101
...
990
991
...
999
```

可以发现规律：我们首先对个位进行了09的排列。之后对十位也进行了09的排列，最后才是百位的0~9排列。由此可以想到用递归的方式，从最高位开始，不断设置下一位要递归的数，一直递归到个位，这样就会先对个位进行排列，递归调用一层层返回，最后才会对最高位进行排列——正好符合上面的分析。

[打印从1到最大的n位十进制数](../../src/17_Print1ToMaxOfNDigits/Print1ToMaxOfNDigits.cpp)

[打印从1到最大的n位十进制数 Java](../../src/17_Print1ToMaxOfNDigits/PrintFrom1ToMaxOfNDigit.java)

### 启示

1. 永远要对数据规模的大小和“大数”保持敬畏，任何简单的问题当数据过大和数据量过大时，难度都会陡然增长。
2. 考虑问题时，不要忽视输入输出的数据规模，选择正确的策略。

## 剑指offer面试题18——删除链表的结点

### 题目一——O(1)删除链表结点

题目描述：
给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间内删除该结点。假设要删除的结点确实在链表中。

常规思路：删除某个结点需要找到该结点的前一个结点，由于单向链表没有指向前一个结点的指针，所以不得不从头指针开始遍历链表。显然时间复杂度为O(n)。实现如下：

```cpp
class DeleteNode {
private:
    Node* haed;

    class Node 
    {
        int val;
        Node* next;
    }

    /**
     * 常规方法，从first开始找到要删除结点的前一个结点，时间复杂度为O(n)
     */
public:
    void deleteNode_2(Node* toBeDel) {
        if (haed == null || toBeDel == null) {
            return;
        }
        // 要删除的就是链表头，它没有前一个结点
        if (haed == toBeDel) {
            haed = haed->next;
        } else {
            Node* cur = haed;
            // 找到被删除结点的前一个结点
            while (cur != null && cur->next != toBeDel) {
                cur = cur->next;
            }
            if (cur != null) {
                // cur为toBeDel的前一个结点
                cur->next = cur->next->next;
            }
        }
    }
}
```

试想一个简单例子，下面是一个链表，假设要删除的结点是C。按照上面的思路是从A开始遍历，找到D的前一个结点B后，然后令B.next = D。

```cpp
A -> B -> C -> D
```

现在要实现O(1)的复杂度，肯定不能从头结点开始，试试直接从要删除的那个结点入手，因此A、B应该都不会被访问到。如果将D结点中的值(value)覆盖C中的值，就变成了下面这样

```cpp
A -> B -> D(new) -> D(original)
```

此时再讲原来的D删除掉，就变成了下面这样，D(new)其实就是原来的C结点，只是值被替换了而已。这样我们只需用到被删除结点及其下一个结点就能实现O(1)时间删除。

```cpp
A -> B -> D(new)
```

有一种特殊情况是：`如果被删除结点是链表的最后一个结点`，比如此时要删除D，就不能按照上面的方法来了，因为D的后面没有结点，其值不能被覆盖；此时还得从头结点开始找到D的前一个结点。

更特殊的情况：如果删除的结点既是最后一个结点又是头结点（只有一个结点的链表），那么直接将头结点置空即可。

[O(1)删除链表结点 C++](../../src/18_01_DeleteNodeInList/DeleteNodeInList.cpp)

[O(1)删除链表结点 Java](../../src/18_01_DeleteNodeInList/DeleteNodeInList.java)

### 题目二——删除链表中的重复结点

题目描述：
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

注意重复的结点不保留：并不是将重复结点删除到只剩一个，而是重复结点的全部会被删除。所以链表1->2->3->3->4->4->5 处理后不是1->2->3->4->5。

思路：从头结点开始遍历链表，因为是删除结点，所以需要知道被删除结点的前一个结点，设为pre；只要当前结点和下一结点不为空，就比较它俩，如果相同，删除当前结点及其后所有值和它相同的结点（由于链表有序，所以值相同的结点必然连续）——只需将pre和第一个不和当前结点值相同的结点相连；**特殊情况是头结点就是重复结点，此时头结点也会被删除，因此需要重新定义头结点。**如果当前结点和下一个结点值不同，就更新当前结点和前一个结点pre，继续上述比较....

[删除链表中的重复结点 C++](../../src/18_02_DeleteDuplicatedNode/DeleteDuplicatedNode.cpp)

[删除链表中的重复结点 Java](../../src/18_02_DeleteDuplicatedNode/DeleteDuplicatedNode.cpp)

### 启示

1. 当我们想删除一个节点时，一般来说需要知道该节点的前一个节点，因为需要更改前一个节点的指针域指向被删节点的下一个节点。
2. 但我们并不一定要删除这个节点本身，可以先把下一个节点的内容复制出来覆盖被删除节点的内容，然后把下一个节点删除。
3. 考察应聘者思维的全面性。

## 剑指offer面试题19--正则表达式匹配

题目描述：
请实现一个函数用来匹配包括`'.'`和`'*'`的正则表达式。模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但是与`"aa.a"`和`"ab*a"`均不匹配

注意`.`就是一个字符，而`*`前面必须有一个字符（可以是`.`）才有意义，所以可以将`x*`看成一个整体，其中`x`表示任意字符。`*`在匹配时有两种情况，第二个字符是`*`或者`不是`。

第二个字符不是`*`号。这种情况很简单，第二个字符要么是`.`要么是一个`具体的字符`。此时如果第一个字符匹配成功了，只需将模式和文本指针都前进一位。比如`ab`和`ac`以及`ab`和`.b`，分别对应着字符一样、模式字符为`.`的情况。第一个字符匹配失败了，直接就可以得出结论——匹配失败。

第二个字符是`*`。有几种情况：

1、`*`匹配`0`次，比如`a*ab`和`ab`匹配，此时需要将模式指针前移2位，文本指针保持不动；

2、`*`匹配了`1`次，比如`a*b`和`ab`匹配，此时需要将模式指针前移2位，文本指针前移1位；

3、`*`匹配了多次，比如`a*b`和`aaab`匹配，此时需要将模式保持不动，文本指针前移1位；

同样的比较第二个字符的前提是第一个字符已经匹配成功。

[正则表达式匹配 C++](../../src/19_RegularExpressionsMatching/RegularExpressions.cpp)

[正则表达式匹配 Java](../../src/19_RegularExpressionsMatching/RegularExpressions.java)

### 启示

1. 本题可以使用正则表达式相关的库函数，但更为重要的是理解匹配的机制。

## 剑指offer面试题20--表示数值的字符串

题目描述：
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

### 正则表达式

这道题有点没意思，就是考虑各种情况，实际上可能还是考虑得不全。第一想到就是直接使用正则表达式。对正则不熟写起来可能要花些时间。

```cpp
bool isNumeric(string str)
{
    regex pattern(R"([+-]?[0-9]*(\.[0-9]*)?([eE][+-]?[0-9]+)?)");
    return regex_match(str, pattern);
}
```

首先第1位可是是+-号中的任意一个，也可以没有；然后是整数部分0~9中任意多位，也可以没有整数部分；然后是小数部分，也是可有可无的，所以用`?`表示小数部分只能出现0次或者`1`次。`e`或者`E`部分也是只能出现`0`次或者`1`次，但是一旦出现`e`或者`E`，后面必须有整数，所以是`[0-9]+`，表示这个整数至少是一位。

### 考虑多种情况，自己实现

如果不使用字符串自带的matches方法呢？

* 字符串长度为1，这个字符必须是0~9中的其中一个
* 第二次出现正负号，该正负号的前一个字符必须是e或者E，比如-5E-3
* 第一次出现正负号，且不在开头出现，该正负号的前一个字符必须是e或者E，比如5E-3
* 小数点只能出现一次，且不能出现在e或者E的后面
* e或者E只能出现一次，e和E的后一个字符必须是整数
* 如果字符不是+-eE.，那么它必须是0~9中任意一个；否则不匹配。

[表示数值的字符串 C++](../../src/20_NumericStrings/NumericStrings.cpp)

[表示数值的字符串 Java](../../src/20_NumericStrings/NumericStrings.java)

### 启示

1. 熟悉正则表达式的规则和在c++下的使用
2. 用逻辑实现正则表达式的方法太过于繁琐。
