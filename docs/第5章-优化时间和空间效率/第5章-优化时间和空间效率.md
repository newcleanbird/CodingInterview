# 第5章-优化时间和空间效率

## 剑指offer面试题42--连续子数组的最大和

>输入一个整型数组，数组里正负数都可能有，数组中的一个或者连续的多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为O(n)

枚举所有的子数组，从中选择最大和可能是很容易想到的办法了，但是总共有$n(n+1) /2$个子数组，最快也需要$O(n^2)$时间复杂度，Pass。

我们可以举例分析数组的特点比如{1, -2, 3, 10, -4, 7, 2, -5}。首先记录下第一个元素，先假设它为最大和。当1加上-2时变成了-1，再加上3等于2，3前面加了一堆还不如不加，所以应该直接从3开始加，即**如果当前累加和是负数，那么它加上当前元素将使得新的累加和比当前元素还要小，此时应该将之前的累加和丢弃，从当前元素开始累加。**

按照上述方法，新的累加和为3大于当前最大和，因此最大和更新为3；加10，当前最大和变成13，继续-4，当前累加和为9，并不大于当前最大和，因此最大和不更新；加7、加2，当前和为18，大于最大和，当前最大和更新为18；最后-5，当前累加和为13，不大于最大和18。遍历完毕，返回最大和18.如果搞清楚了上面的思路，可以很容易写出如下代码:

```java
package Chap5;

public class FindGreatestSumOfSubArray {
    public int findGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0) return 0;

        int maxSum = array[0];
        int curSum = array[0];
        for (int i = 1; i < array.length; i++) {
            // 丢弃累结合，从当前元素开始累加
            if (curSum < 0) curSum = array[i];
            // 累加
            else curSum += array[i];
            // 和当前最大和比较，若比它大就更新
            if (curSum > maxSum) maxSum = curSum;
        }
        return maxSum;
    }
}

```

没几行，只需遍历一次，时间复杂度为O(n).

### 动态规划

还可以用动态规划的思想，用$f(i)$表示以第i个数字结尾的子数组，其中$0 \le i < n $，那么我们要求的就是$max[f(i)]$。

$$f(i) = array[i], i=0 或者f(i-1) < 0$$

$$f(i) = f(i -1) + array[i], i \neq 0 且f(i -1) \ge 0$$

**动态规划最重要的就是要保存中间计算结果**，这里$f(i)$其实就是上面的curSum，$max[f(i)]$的计算变成了两两比较，其实就是上面的maxSum。可以看到和上面的方法是异曲同工的。这里保存的中间计算结果就是curSum和maxSum，当$f(i-1) < 0$时对应着上面curSum < 0. 否则就累加，然后求$max[f(i)]$可以通过两两比较得到最终的最大和，也就是$f(i)$和当前的max比较选择较大的那个。

```java
package Chap5;

public class FindGreatestSumOfSubArray {
    /**
     * 动态规划，其实和上面是一样的代码...
     */
    public int FindGreatestSumOfSubArray2(int[] array) {
        if (array == null || array.length == 0) return 0;

        int maxSum = array[0];
        int curSum = array[0];
        for (int i = 1; i < array.length; i++) {
            // if (curSum + array[i] < array[i]),也就是if (curSum < 0) 则curSum的结果是array[i]
            // 否则curSum的值是curSum + array[i]
            curSum = Math.max(curSum + array[i], array[i]);
            // 如果curSum > maxSum,则maxSum取curSum，否则maxSum = maxSum
            maxSum = Math.max(curSum, maxSum);
        }
        return maxSum;
    }
}
```

## 剑指offer面试题43--1~n整数中1出现的次数

>输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数，例如输入12, 1~12中出现1的有1、10、11、12共5次

### 计算每个数字出现1的次数

比较直接的思路就是写一个方法可以统计任意整数1的个数，然后用一个循环得到对1~n每一个数调用该方法统计总的1的出现次数。

```java
package Chap5;

public class NumOf1 {
    /**
     * 方法1，计算每个数字中1的个数，复杂度O(nlgn)
     */
    public int NumberOf1From1To(int n) {
        // 正负数不影响1的个数，统一变成非负数
        if (n < 0) n = Math.abs(n);

        int count = 0;
        // 循环求n个数字，共O(nlgn)的时间
        for (int i = 1; i <= n; i++) {
            count += numOf1(i);
        }
        return count;
    }

    /**
     * O(lgn)的复杂度求一个数中含有1的数量
     */
    private int numOf1(int n) {
        int count = 0;
        while (n != 0) {
            if (n % 10 == 1) count++;
            n = n / 10;
        }
        return count;
    }
}

```

`numOf1`方法中，n % 10可以得到个位，n = n / 10表示丢弃最低位。该方法的复杂度为O(lgn)，对于1~n中n个数字都要调用一遍该方法，总的时间复杂度是O(nlgn)。

### 更暴力的解法--StringBuilder拼接

使用StringBuilder将1~n的所有数无缝拼接起来，然后一个个数。

```java
package Chap5;

public class NumOf1 {
    /**
     * 方法2：使用StringBuilder将所有数字拼接，无脑数数
     */
    public int numOf1Between1AndN(int n) {
        // 正负数不影响1的个数，统一变成非负数
        if (n < 0) n = Math.abs(n);

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append(i);
        }

        int count = 0;
        for (int i = 0; i < sb.length(); i++) {
            if (sb.charAt(i) == '1') {
                count++;
            }
        }
        return count;
    }
}
```

### 神一样的方法

参考[LeetCode](https://discuss.leetcode.com/topic/18054/4-lines-o-log-n-c-java-python)

1可以出现在任意一位，比如3245，1出现在个、十、百、千位都可以。只要固定某一位为1，计算出该位是1的所有情况，将固定每一位得到的情况数相加就是最终结果。

要固定某一位为1，可以使用m = 1, 10, 100, 1000....，对n作除、余操作，将输入整数分为高位和低位两部分。举个例子，对于输入n = 3101592，m = 100，如果令a = n / m, b = n % m，将得到a = 31015，b= 92两部分，现在固定百位为1（始终固定a的最低位），即`xxxx1xx`这样的形式，这样形式的数有多少个呢？

```s
0000 1 00
0000 1 01
.....
0000 1 99
0001 1 00
......
0001 1 99
0002 1 00
......
0002 1 99
......
3101 1 00
......
3101 1 99
```

为了看得直观，上面刻意将数字从百位处分隔开，对于百位之前的高位数，总共有`0000~3101`共3102种情况，而每一种情况对应着低位有`00~99`共100种情况，因此百位为1的情况数是3102*100，也就是`(a / 10 + 1) * m`种情况。好，现在得到百位为1的情况数了，个位与千位等其他位计算方法和上面类似，只需取不同的m就能将输入的整数分成两部分并固定某一位为1.

接下来m = 1000时，3101592被分成a = 3101和b = 592两部分，现在固定千位为1，但是此时千位本来就是1了，来看和上面有什么不同

```s
000 1 000
......
000 1 999
309 1 000
......
309 1 999
310 1 000
......
310 1 592
```

可以看到千位前的高位从`000~309`和上面一样，每一种情况都有`000~999`种可能，但是到310时，后面最多只能到592，共`000~592`是593种情况。此时千位为1的情况总数为：310 * 1000 + 593，即**当前要被固定的位在输入中本来就是1**的话有`(a / 10) * m + b + 1`种情况。

再看m = 10000，固定万位的情况。a = 310, b = 1592.

```s
00 1 0000
......
00 1 9999
30 1 0000
......
30 1 9999
```

没有了，共31 * 10000种，即**当前要被固定的位在输入中是0**的话有`(a / 10) * m`种情况。

一开始固定百位其实就是**当前要被固定的位在输入中是2~9**这种情况。

分析得差不多了，现在考虑这三种情况计算就好了。

```java
/**
 * 方法三
 */
public int numberOf1(int n) {
    int ones = 0;
    for (long m = 1; m <= n; m *= 10) {
        long a = n / m;
        long b = n % m;
        if (a % 10 == 0) ones += a / 10 * m;
        else if (a % 10 == 1) ones += (a / 10 * m) + (b + 1);
        else ones += (a / 10 + 1) * m;
    }
    return ones;
}
```

## 剑指offer面试题44--数字序列中的某一位数字

>数字以0123456789101112131415....的格式序列化得到一个字符序列中，在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字

### 逐个列举

有一种方法，每列举一个数字就记录当前序列长度和，比如列举到3，序列的长度和为4，列举到10，长度和为12...以此类推。当某次列举使得当前长度和大于给定的n时，停止列举，**第n位数一定在在刚列举的数中**，接下里只需从这个数中找出是哪一位即可。

```java
package Chap5;

public class ADigitInNumberSeq {
    /**
     * 方法1：逐个列举
     */
    public int numAtSeq(int index) {
        if (index < 0) return -1;

        int i = 0;
        int sum = 0;
        while (true) {
            sum += countDigits(i);
            // 一定不要包含=
            if (sum > index) break;
            i++;
        }
        // sum - n是超出的部分，减去1是因为下标从0开始
        return digitAt(i, sum - index - 1);
    }

    /**
     * 返回某数的第d位, 第0位是个位，第1位是十位，以此类推
     */
    private int digitAt(int value, int d) {
        return (value / (int) Math.pow(10, d)) % 10;
    }

    /**
     * 计算某数有多少位
     */
    private int countDigits(int num) {
        if (num == 0) return 1;

        int count = 0;
        while (num != 0) {
            num /= 10;
            count++;
        }
        return count;
    }
}

```

当前长度和sum > index时候退出循环，此时第index位一定在数字i中，那到底是数字i的第几位呢？举个例子

```s
012345678910111213...
```

找index = 16的数，当列举到13时候，当前长度和sum = 18 > 16，此时i = 17，容易得知index位是1，即17的第0位。多举几个例子就容易发现只要取数字`i`的第`sum - index -1`位就是我们要找的数字。

### 更快的方法

从数字本身的规律入手。如果要找第1001位，肯定不会考虑0~9折十位吧？接下来10-99也就有180位而已，不考虑，每次不考虑的情况需要减去已缩小查找范围，因此在排除掉0-99共180+10后还剩881，也就是说我们原来是从0开始找到第1001位，现在只需从100开始找到第991位即可。接下来看100-999共2700位，由于881  < 2700，所以这个数必然在100~999的范围内。881 = 270 * 3 + 1，说明这个数是100开始之后的第270个数的第1位（从0开始计算索引），也就是370的第一位数，即7。

有了思路后，要实现几个关键的方法，首先是根据位数得到一个区间的开始数字。区间划分为：0-9， 10-99， 100-999...比如n = 1，一位数的开始数是0; n = 2,两位数的开始数是10; n = 3,三位数的开始数是100...

其次因为要缩小查找范围，所以要根据位数知道该范围内总共有多少个数字，比如n = 1, 一位数0-9的范围共10个数；n = 2，两位数10-99的范围共90个数；n = 3，三位数100-999的范围共900个数....

还需要一个方法，一旦锁定范围，根据当前的位数能知道包含index处数字的数是几，然后从该数中找到要求的那位。

 ```java
package Chap5;

public class ADigitInNumberSeq {
    /*****************************************
     * 方法2
     */
    public int numAtSeq2(int index) {
        if (index < 0) return -1;
        // 位数，digits = 1表示一位数，0-9区间；digits = 2表示两位数，10-99区间...
        int digits = 1;
        while (true) {
            int numbers = numOfRange(digits);
            // 范围锁定，numbers * digits表示该区间共有多少位数字，如digits = 2，范围10-99就有180位
            if (index < numbers * digits) {
                return digitAt2(index, digits);
            }
            // 缩小范围
            index -= numbers * digits;
            digits++;
        }
    }

    /**
     * 根据位数得到范围内的个数，比如1位，0~9共10个
     * 2位，10~99共90个
     * 3位，100~999共900个
     * ...
     */
    private int numOfRange(int n) {
        if (n == 1) return 10;

        return (int) (9 * Math.pow(10, n - 1));
    }

    /**
     * n位数范围内的的第一个数，比如1位数，0~9，第一个是0
     * 2位数，10~99，第一个数是10
     * 3位数，100~199，第一个数是100
     */
    private int beginNumber(int n) {
        if (n == 1) return 0;
        return (int) Math.pow(10, n - 1);
    }
    // 锁定范围后，根据位数就能得到包含index处那位数的数字，然后从该数中找到要求的那位 
    private int digitAt2(int seqIndex, int digits) {
        int number = beginNumber(digits) + seqIndex / digits;
        return digitAt(number, digits - seqIndex % digits - 1);
    }

    public static void main(String[] args) {
        ADigitInNumberSeq a = new ADigitInNumberSeq();
        System.out.println(a.numAtSeq(1001)); // 7
        System.out.println(a.numAtSeq2(1001)); // 7
    }
}

 ```

重点看`digitAt2`方法

```java
private int digitAt2(int seqIndex, int digits) {
    int number = beginNumber(digits) + seqIndex / digits;
    return digitAt(number, digits - seqIndex % digits - 1);
}
```

`seqIndex / digits`表示该区间开始数字其后多少位是我们要找的数字，再加上`beginNumber(digits)`就得到了我们要找的数字，比如上面的例子811 / 3 = 270，说明是开始数字100其后的270位，于是我们知道了这个数是370，接下来`seqIndex % digits`取余操作可以得到数是370第1位，**由于得到的余数是从左往右数的，而digitAt方法是从右往左数的**。因此取`digits - seqIndex % digits -1`才能得到正确结果。

## 剑指offer面试题45--把数组排成最小的数

>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

这道题可以对数组排序，比如对于普通的数组{23, 12, 32}，可能会想到按照自然序排序后，得到{12, 23, 32}然后直接拼接起来就得到了最小的数字122332，但是像题中的例子按照自然序排好后就是{3, 32, 321}，如果直接拼接得到332321，是不是最小呢？可以发现排好后是{321, 32, 3}，才能得到最小数321323。**可见这已经不是自然序了，所以想到需要自定义一种比较方法，得到一种新的排序方式。**

既然是要拼接数组中所有的数，保证拼接后的数最小，我们从最小的问题出发，当数组中只有两个数时，情况很简单，比如{3, 32}，有用两种方式拼接他们`"3"+"32"`和`"32"+"3"`，分别为332和323，因为323 < 332，所以将32排在3的前面，也就是对于数组中的任意两个数m和n，如何mn < nm，则应该将m排在n的前面。在Java中很好实现，只需重写一个Comparator即可。使用Java 8的lambda表达式可以简化这一过程。

```java
package Chap5;

import java.util.ArrayList;
import java.util.List;

public class PrintMinNumber {
    public String printMinNumber(int[] numbers) {
        if (numbers == null || numbers.length == 0) return "";

        List<Integer> list = new ArrayList<>();
        for (int a : numbers) {
            list.add(a);
        }
        // 这句是核心，即比较ab和ba的大小，小的排在前面
        list.sort((a, b) -> (a + "" + b).compareTo(b + "" + a));
        StringBuilder sb = new StringBuilder();
        for (int a : list) {
            sb.append(a);
        }
        return sb.toString();
    }
}
```

## 剑指offer面试题46--把数字翻译成字符串

> 给定一个数字，我们按照如下的规则把它翻译成字符串
> 0 -> a
> 1 -> b
> 2 -> c
> ...
> 25 -> z
>
> 一个数字可能有多种翻译，比如12258有五种，分别是"bccfi", "bwfi","bczi","mcfi", "mzi".请实现一个函数，用来计算一个数字有多少种不同的翻译方法。

举个简单的例子，比如258，我们可以先翻译第一个数字，得到c，也可以翻译前两个数字，得到z；如果先翻译了一个数，对于剩下的58，和上面一样可以选择只翻译一位，得到f，也可以翻译两位（在这个例子中是不合法的，58没有与之映射的字符），如果先翻译了两位，对于剩下的8，只能有一种翻译方法了，得到i。所以最后得到两种翻译方法，cfi和zi。

从这个简单的例子可以得到一般性的结论，令f(i)为从第i位开始的不同翻译的数目，因为每次可以选择值翻译一个数字，也可一次翻译两个数字，而对于剩下的数字也可以采用同样的方法，这是一个递归问题。

$$f(i) = f(i+1) + g(i, i+1)f(i+2), 0 \le i < n$$

其中n为数字的位数，$g(i, i+ 1)$可取0或者1，当一次翻译两个数字时，如果这个数字在$10 \le m \le25$的范围内，这就是一个可翻译的数，此时$g(i, i + 1)$为1，否则为0。根据题意，我们最后就是要求得$f(0)$

### 从左到右翻译的递归

根据上面的思路，可写出从左到右翻译的递归解法。

```java
package Chap5;

import java.util.ArrayList;
import java.util.List;

public class TransLateNumToString {
    /**
     * 方法一：从左到右的递归，重复计算较多，但是可以保存编码的结果
     */
    public List<String> translateNum(int n) {
        List<String> list = new ArrayList<>();
        if (n < 0) return list;

        String number = String.valueOf(n);
        StringBuilder sb = new StringBuilder();
        translate(sb, number, list);
        return list;
    }

    private void translate(StringBuilder sb, String str, List<String> list) {
        if (str.equals("")) {
            list.add(sb.toString());
            return;
        }
        // 一次只翻译一个数
        String s1 = str.substring(0, 1);
        char letter1 = numToLetter(s1);
        sb.append(letter1);
        translate(sb, str.substring(1), list);
        sb.deleteCharAt(sb.length() - 1);
        // 一次翻译两个数
        if (str.length() >= 2) {
            String s2 = str.substring(0, 2);
            if (check(s2)) {
                char letter2 = numToLetter(s2);
                sb.append(letter2);
                translate(sb, str.substring(2), list);
                sb.deleteCharAt(sb.length() - 1);
            }
        }

    }
    /**
     * 当一次翻译两位数时，检查是否范围在10-25之间
     */
    private boolean check(String num) {
        int val = Integer.parseInt(num);
        return val >= 10 && val <= 25;
    }
    /**
     * 数字 -> 字母的映射，a的ASCII码是97，所以0-25的数字加上97就得到了题      * 目中的映射
     */ 
    private char numToLetter(String num) {
        return (char) (Integer.parseInt(num) + 97);
    }

}
```

使用StringBuilder拼接每次翻译的结果，到字符串的结尾说明翻译完毕，将该翻译结果存到一个list中，StringBuilder每次append一个翻译字符然后递归地对其后的字符进行同样的操作，但是递归结束后，StringBuilder需要删除掉这个刚添加了翻译字符，实际上就是模拟了进出栈的过程，这保证了StringBuilder在其他递归调用中表示的翻译字符结果正确。注意只有当当前字符串长度大于等于2才能一次翻译两个数字，因此在翻译两个数字时别忘了判断下。

这种方法，调用了很多次substring，空间上很浪费，而且自上而下的递归中有很多重复计算，效率并不高。但是该方法可以保存每种翻译的结果。

### 从右往左翻译的循环

如果自下而上，从小的结果出发，保存每一步计算的结果，以供下一步使用，也就是我们按照从右到左的顺序翻译。

$$f(i) = f(i+1) + g(i, i+1)f(i+2), 0 \le i < n$$

对于上面的公式，也就是先求出$f(n -1)$，然后求出$f(n -2)$，之后根据这两个值求出$f(n -3)$，然后根据$f(n-2)$和$f(n -3)$求出$f(n -4)$一直往左知道求出$f(0)$，这就是我们要的结果！

```java
package Chap5;

import java.util.ArrayList;
import java.util.List;

public class TransLateNumToString {
    /**
     * 方法二：从右到左的循环，效率高，单纯的计数
     */
    public int getTranslateCount(int n) {
        if (n < 0) return 0;
        return count(String.valueOf(n));
    }

    private int count(String num) {
        int len = num.length();
        int[] counts = new int[len];
        // f(n -1)必然为1
        counts[len - 1] = 1;

        for (int i = len - 2; i >= 0; i--) {
            int high = num.charAt(i) - '0';
            int low = num.charAt(i + 1) - '0';
            int combineNum = high * 10 + low;
            if (combineNum >= 10 && combineNum <= 25) {
                // f(i) = f(i+1) +f(i+2),if中因为f(i+2)不存在，但是该值肯定为1
                if (i == len -2) counts[i] = counts[i+1] + 1;
                else counts[i] = counts[i+1]+counts[i+2];
            } else {
                // f(i) = f(i+1)
                counts[i] = counts[i+1];
            }

        }
        // 从第一个数字开始的不同翻译数目
        return counts[0];
    }

    public static void main(String[] args) {
        TransLateNumToString t = new TransLateNumToString();
        System.out.println(t.translateNum(187534121).size());
        System.out.println(t.getTranslateCount(187534121));
    }
}

```

上面的代码就是把公式翻译了一遍，其中counnts数组存放每一步计算的结果，即保存$f(0)$~$f(n -1)$的值。$f(n -1)$说明只有一位数，必然只有一种翻译方法；同样注意，当$i = n -2$时候，$f(i+2)$将超出范围，需要特别处理，这种情况就是说，对于两位数比如18，肯定有两种翻译方法，即$f(n -1) + 1 = 2$种。

最后一步得到counts[0]即$f(0)$返回即为答案。

这种方法只需遍历数字的每一位即可，实现了题目的要求计算出了翻译数目，但是没有办法表示出翻译结果。

## 剑指offer面试题47--礼物的最大价值

> 在一个mxn的棋盘的每一格斗放油一个礼物，每个礼物都有一定的价值（大于0）从棋盘的左上角开始，每次可以往右边或者下边移动一格，知道到达棋盘的右下角。给定一个棋盘和上面的礼物，计算我们最多可以拿到多少价值的礼物

### 递归--两个方向的深度优先搜索

我第一想到的是递归，然后被书上打脸。不管，还是实现一下吧。

```java
package Chap5;

public class MaxGiftVal {
    /**
     * 方法一：递归，两个方向的深度优先搜索，用一个对象数组保存最大值（只需一个长度）
     */
    public int getMax(int[] gifts, int rows, int cols) {
        if (gifts == null || gifts.length == 0) return 0;
        int[] max = {0};
        select(gifts, 0, 0, rows, cols, 0, max);
        return max[0];
    }

    private void select(int[] gifts, int row, int col, int rows, int cols, int val, int[] max) {
        if (row >= rows || col >= cols) return;
        // 一维数组表示，对应着二维数组中的array[row][col]
        val += gifts[row * cols + col];
        // 到达右下角，和max比较
        if (row == rows - 1 && col == cols - 1) {
            if (val > max[0]) max[0] = val;
        }
        select(gifts, row + 1, col, rows, cols, val, max);
        select(gifts, row, col + 1, rows, cols, val, max);
    }
}
```

每进入一个格子，累加礼物价值。当到达右下角时，将累加和与全局的max变量比较，如果某条路径的累加和比max大，就更新max。边界控制很重要，在超出行或者超出列的范围后，直接返回。然后就不断在两个方向递归——右边或者下边。全局max由于是int型，作为参数并不能在递归调用后被改变，所以需要一个**对象**，由于只需要存放一个值，一个长度为1的对象数组即可。

### 动态规划--要到达当前格子有两个方向

设当前格子能获得的最大礼物价值为$f(i, j)$, 要到达该位置，只有两种情况：

- 从该位置的左边来，即$f(i, j-1)$
- 从该位置的上边来，即$f(i-1, j)$

$f(i, j)$处的礼物价值设为$gift(i, j)$

那么到达$f(i, j)$处能收集到的最大礼物价值为

$$max[f(i, j- 1), f(i-1, j)]+gift[i, j]$$

可以发现，要知道当前格子能获得最大礼物价值，需要用到当前格子左边一个和上面一个格子的最大礼物价值和。所以从左上角开始，计算到达每一个格子能获得最大礼物价值是多少，并保存下这些结果。在后面求其他格子的最大礼物价值时会用到前面的结果。基于这个思路可写出如下代码。

```java
package Chap5;

    /**
     * 方法2：动态规划，到达f(i,j)处拥有的礼物价值和有两种情况：
     * 1、从左边来，即f(i, j) = f(i, j -1) + gift(i, j)
     * 2、从上边来，即f(i, j) = f(i -1, j) + gift(i, j)
     *
     * 保证到达每一个格子得到的礼物价值之和都是最大的，也就是取max[f(i, j-1), f(i-1, j)] +gift(i, j)
     * 可以发现，要知道当前格子能获得最大礼物价值，需要用到当前格子左边一个和上面一个格子的最大礼物价值和
     */

    public int getMaxVal(int[] gifts, int rows, int cols) {
        if (gifts == null || gifts.length == 0) return 0;
        int[][] maxVal = new int[rows][cols];
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int left = 0;
                int up = 0;
                if (row > 0) up = maxVal[row -1][col];
                if (col > 0) left = maxVal[row][col -1];
                maxVal[row][col] = Math.max(up, left) + gifts[row *cols+col];
            }
        }
        return maxVal[rows-1][cols-1];
    }
```

用到一个二维数组保存到达每一个格子时能获得的最大礼物价值。up和left分别是上面说的$f(i-1, j)$和$f(i, j -1)$，循环完毕后，返回到达右下角处能获得最大礼物价值即可。

### 上面方法的优化——用一维数组代替二维数组

当前礼物的最大价值只依赖$f(i-1, j)$和$f(i, j -1)$这两个格子，因此只需要当前行i，第j列的前面几个格子，也就是$f(i, 0)$~$f(i, j-1)$；以及i -1行的，第j列及其之后的几个格子，也就是$f(i-1, j)$~$f(i-1, cols-1)$

两部分加起来的个数刚好是棋盘的列数cols。所以只需要一个长度为cols的一维数组即可，优化如下。

```java
package Chap5;

    public int betterGetMaxVal(int[] gifts, int rows, int cols) {
        if (gifts == null || gifts.length == 0) return 0;
        int[] maxVal = new int[cols];
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int left = 0;
                int up = 0;
                if (row > 0) up = maxVal[col];
                if (col > 0) left = maxVal[col -1];
                maxVal[col] = Math.max(up, left) + gifts[row *cols+col];
            }
        }
        return maxVal[cols-1];
    }
```

`int[] maxVal = new int[cols];` 中，索引为`0~j-1`的就是$f(i, 0)$~$f(i, j-1)$，索引`j~cols-1`的就是$f(i-1, j)$~$f(i-1, cols-1)$

## 剑指offer面试题48--最长不含重复字符串的子字符串

> 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含'a'~'z'之间的字符，例如在字符串"arabcacfr"中，最长的不含重复字符的子字符串是"acfr"，长度为4

动态规划，**定义$f(i)$表示以第i个字符为结尾的不含重复字符的子字符串长度。**

如果第i个字符之前没有出现过，则$f(i) = f(i -1) +1$，比如‘abc',$f(0) = 1$是必然的，然后字符’b‘之前没有出现过，则$f(1) = f(0)+1$, 字符’c'之前没有出现过，那么$f(2) = f(1) +1$,每次计算都会用到上一次计算的结果。

如果第i个字符之前出现过呢？找到该字符上次出现的位置preIndex，当前位置i - preIndex就得到这两个重复字符之间的距离，设为d。此时有两种情况

- 如果`d <= f(i-1)`,说明当前重复字符必然在f(i-1)所对应的字符串中，比如’bdcefgc‘，当前字符c前面出现过了，preIndex为2，此时`d = 6 -2 = 4` ,小于`f(i -1) = 6 (bdcefg)`我们只好丢弃前一次出现的字符c及其前面的所有字符，得到当前最长不含重复字符的子字符串为’efgc‘，即`f(i) = 4`, 多举几个例子就知道，应该让`f(i) = d`；

- 如果`d > f(i-1)`, 这说明当前重复字符必然在f(i-1)所对应的字符串**之前**，比如`erabcdabr`当前字符r和索引1处的r重复，`preIndex =1, i = 8,d = 7`。而`f(i -1) = 4 (cdab)`,此时直接加1即可，即`f(i) = f(i-1) +1`

根据这两种情况可写出代码如下：

```java
package Chap5;

public class LongestSubstring {
    public  int lengthOfLongestSubstring(String str) {
        if (str == null || str.length() == 0) return 0;
        int curLen = 0;
        int maxLen = 0;
        // 0~25表示a~z，position[0] = index,表明a上次出现在index处
        int[] position = new int[256];
        for (int i = 0; i < 256; i++) {
            position[i] = -1;
        }

        for (int i = 0; i < str.length(); i++) {
            int preIndex = position[str.charAt(i)];
            // 字符第一次出现，或者d > f(i -1)
            if (preIndex == -1 || i - preIndex > curLen) curLen++;
            // d <= f(i -1) 
            else {
                curLen = i - preIndex;
            }
            // 记录当前字符出现的位置
            position[str.charAt(i)] = i;
            if (curLen > maxLen) maxLen = curLen;
        }
        return maxLen;

    }
}
```

用了一个数组position代替哈希表，记录每个字符上次出现的位置，能以O(1)的时间完成，先要将position中的值全初始化为-1，因为上次出现的位置可能含有索引0。 curLen就是上面说到的$f(i -1)$

如果某个字符第一次出现，那么它上次出现的位置preIndex为-1。当前最长不重复子字符串直接加1。

只有else语句中curLen才可能变小，因此要即使保存到maxLen，因为这个curLen可能就是最长的。而且if语句中curLen++并没有和maxLen比较，所以除了循环后还要再和maxLen比较一次。

## 剑指offer面试题49--丑数

> 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

穷举法，挨个判断是否是丑数，即使那个数不是丑数也要判断，显然时间复杂度太高。

有没有方法每一步计算只是得到丑数呢？根据丑数的定义，所有丑数都是2、3、5这三个因子的任意搭配的任意多次乘积，比如2x2，2x3, 2x2x3x5等等。那么从1开始，分别乘以2、3、5，得到2、3、5三个丑数，但是这并不是正确的排序，我们知道3、5之间还有个4也是丑数。1之后的下一个丑数，一定是2、3、5其中的一个，显然应该选三者中最小的2，现在丑数集合为{1, 2}且有序，刚才选走的2是1x2得到的，因此下一个和2相乘的丑数应该是1之后的数字2（丑数集合已经有序，直接选择下一个）。现在又得到三个候选的丑数4、3、5，再次选择三者中最小的3，得到当前丑数集合{1, 2, 3}，刚被选走的3由1x3得到，因此下一个要和3相乘的按照丑数集合的顺序应该是2，然后又得到了三个候选的丑数4、6、5，选择最小的4.....不断重复，自始至终只和丑数打交道。

设定三个数t2、t3、t3专门用于分别和2、3、5相乘，某次选择中选走了ti，那么ti从丑数集合中选择下一个数，下次再和i相乘生成一个新的候选丑数，本次没有被选中的，下次继续参与比较。这样能保证下一个丑数一定在三个候选项中，且是三个候选项中最小的那个。

```java
package Chap5;

public class UglyNumber {
    public int uglyNumber(int index) {
        if (index <= 0) return 0;
        int t2 = 0;
        int t3 = 0;
        int t5 = 0;
        int[] res = new int[index];
        // 第一个丑数为1
        res[0] = 1;
        for (int i = 1; i < index; i++) {
            int m2 = res[t2] * 2;
            int m3 = res[t3] * 3;
            int m5 = res[t5] * 5;
            // 三个候选中最小的就是下一个丑数
            res[i] = Math.min(m2, Math.min(m3, m5));
            // 选择某个丑数后ti * i，指针右移从丑数集合中选择下一个丑数和i相乘，注意是三个连续的if，也就是三个if都有可能执行。这种情况发生在三个候选中有多个最小值，指针都要右移，不然会存入重复的丑数
            if (res[i] == m2) t2++;
            if (res[i] == m3) t3++;
            if (res[i] == m5) t5++;
        }
        return res[index - 1];
    }
}
```

## 剑指offer面试题50--第一个只出现一次的字符

> 找出字符串中找出第一个只出现一次的字符，比如输入“abacceff",则输出'b'

要想知道某个字符是不是只出现了一次，必须遍历字符串的每个字符。**因此可以先遍历一次，统计每个字符出现次数。再遍历一次，遇到某个字符出现字符为1就立即返回。**统计每个字符出现次数，可以用哈希表，不过如果输入中都是ASCII码，那么使用0-255表示即可。这样使用一个`int[] count = new int[256]`就能代替哈希表了，以`count[someChar] = times`这种方式表示某个字符出现的次数。比如‘a’的ASCII码是97，那么count[97]就表示了字符'a'的出现次数，以此类推。

```java
package Chap5;

public class FirstAppearOnceChar {
    /**
     * 返回第一个不重复字符
     */
    public char firstNotRepeatingChar(String str) {
        if (str == null || str.length() == 0) return '\0';
        int[] count = new int[256];

        for (int i = 0; i < str.length(); i++) {
            count[str.charAt(i)]++;
        }
        for (int i = 0; i < str.length(); i++) {
            if (count[str.charAt(i)] == 1) return str.charAt(i);
        }
        return '\0';
    }

    /**
     * 返回第一个不重复字符在字符串中的索引
     */
    public int firstAppearOnceChar(String str) {
        if (str == null || str.length() == 0) return -1;
        int[] count = new int[256];

        for (int i = 0; i < str.length(); i++) {
            count[str.charAt(i)]++;
        }
        for (int i = 0; i < str.length(); i++) {
            if (count[str.charAt(i)] == 1) return i;
        }
        return -1;
    }
}
```

上面两个方法，一个是返回第一个只出现一次的字符，一个返回第一个只出现一个的字符的索引，思路都一样。根据`count[someChar]`获取某个字符的出现次数时间复杂度为O(1),对于长度为n的字符串，总的复杂度为O(n).

不过如果输入中含有特殊符号或者中文等，256位的ASCII表就不够用了，需要上Unicode了，总之看题目要求吧，要想通用就哈希表。

### 相关题目

#### 扩展一

> 定义一个函数，输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。比如第一个字符串"google"，第二个字符串为"aeiou"，删除后得到"ggl".

使用一个`boolean occur[] = new int[256]`布尔型数组，对于第二个字符串中的每个字符，标记为true表示出现过。遍历第一个字符串，判断每个字符在occur中是不是fale，为false说明该字符没有在第二个字符串中出现过，保留。

```java
/**
 * 从第一个字符串中删除第二个字符串中出现过的所有字符
 */
public String deleteFromAnother(String str, String another) {
    if (str == null || str.length() == 0 || another == null || another.length() == 0) return str;
    boolean[] occur = new boolean[256];
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < another.length(); i++) {
        occur[another.charAt(i)] = true;
    }

    for (int i = 0; i < str.length(); i++) {
        if (!occur[str.charAt(i)]) sb.append(str.charAt(i));
    }
    return sb.toString();
}
```

#### 扩展二

> 定义一个函数，删除一个字符串中所有重复出现的字符，比如输入"google"返回"gole"

使用一个`boolean occur[] = new int[256]`布尔型数组，记录某个字符是否出现过。刚开始都初始化false，每添加一个字符就标记为true，这样下次遇到重复字符就不会再添加了。

```java
/**
 * 删除字符串中所有的重复字符
 */
public String deleteRepeating(String str) {
    if (str == null || str.length() == 0) return str;

    boolean[] occur = new boolean[256];
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < str.length(); i++) {
        char ch = str.charAt(i);
        if (!occur[ch]) sb.append(ch);
        occur[ch] = true;
    }
    return sb.toString();
}
```

#### 扩展三

> 变位词，如果两个单词含有相同的字母且每个字母出现的次数还一样，那么这两个单词互为变位词。定义一个函数判断两个字符串是不是互为变位词。

两个字符串含有相同的字母、每个字母出现的次数一样，先统计第一个字符串每个字符出现的次数，然后遍历第二个字符串，对于每个出现的字符，将统计表中相应字符的出现次数减1，**如果啷个字符串是变位词，那么遍历结束后，统计表中每个字符出现的字符都是0**。

```java
/**
 * 变位词
 */
public boolean hasSameChar(String s1, String s2) {
    if (s1 == null || s2 ==null) return false;
    int[] count = new int[256];
    // 统计第一个字符串
    for (int i = 0; i < s1.length(); i++) {
        count[s1.charAt(i)]++;
    }
    // 第二个字符串中如果有该字符，就减去
    for (int i = 0; i < s2.length(); i++) {
        count[s2.charAt(i)]--;
    }
    // 如果是变位词，最后count数组每个位置都是0
    for (int i = 0; i < 256; i++) {
        if (count[i] != 0) return false;
    }
    return true;
}
```

#### 题目二

> 字符流中第一个只出现一次的字符。
> 这次字符串是动态变化的了，比如现在只从字符流中读取了两个字符为"go"那么字符流中第一个只出现一次的字符是'g'，等到从字符流中读取了前6个字符"google"时，第一个只出现一次的字符变成了'l'.

使用一个insert函数模拟从字符流中读到一个字符。这次统计表`int[] occur = new int[256]`记录的是字符出现的索引.

- 如果某个字符出现过，那么`occur[someChar] >= 0`;
- 对于没有出现过的字符，令`occur[someChar] = -1`;
- 如果某个字符第二次出现，令`occur[someChar] = -2`。

要获得当前字符串中第一个只出现一次的，只需从所有`occur[someChar] >= 0`中结果中找出出现索引最小的那个字符即可。

```java
package Chap5;

public class AppearOnceInStream {
    // 记录某个字符出现的索引
    private int[] count;
    // 当前读取到的字符在字符串中的索引
    private int index;
    public AppearOnceInStream() {
        count =  new int[256];
        for (int i = 0; i < count.length; i++) {
            count[i] = -1;
        }
    }
    // 模拟读取字符流中的下一个字符
    public void insert(char c) {
        if (count[c] == -1) count[c] = index;
        else if (count[c] >= 0) count[c] = -2;
        index++;
    }

    public char firstAppearOnceChar() {
        int minIndex = Integer.MAX_VALUE;
        char c = '\0';
        for (int i = 0; i < count.length; i++) {
            // 从所有count[i] >= 0的结果中找出最小的索引就是第一个只出现一次的字符
            if (count[i] >= 0 && count[i] < minIndex) {
                minIndex = count[i];
                c = (char)i;
            }
        }
        return c;
    }

    public static void main(String[] args) {
        AppearOnceInStream a = new AppearOnceInStream();
        a.insert('g');
        a.insert('o');
        System.out.println(a.firstAppearOnceChar());
        a.insert('o');
        a.insert('g');
        a.insert('l');
        a.insert('e');
        System.out.println(a.firstAppearOnceChar());
    }
}
```

## 剑指offer面试题51--在排序数组中查找数字

> 统计一个数字在排序数组中出现的次数。

### 遍历

这是很容易想到的方法了，但时间复杂度O(n)，不推荐。

```java
package Chap6;

public class NumOfK {
    /**
     * 方法一：遍历，O(n)复杂度，不推荐
     */
    public int getNumberOfK(int[] array, int k) {
        if (array == null) return 0;

        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i] == k) {
                count++;
            }
        }
        return count;
    }
}
```

### 二分法

既然是排序数组，自然容易想到二分法查找。假设要查找的数字为k，只需找到第一个k的下标、最后一个k的下标，就达到了计数的目的。

先来找第一个k的下标：由于有多个k，因此当在mid处找到k时，不要急于返回。如果k之前的数还是k，那么我们还要继续在左子数组中查找，直到某个mid处的值为k但是它前面的值不是k、或者mid都等于0了（即第一个k出现在下标0处）；

然后找最后一个k的下标：同样地，如果mid处是k，且它的后面还是k，需要在右子数组中继续查找，直到mid处为k但它后面不是k、或者mid都等于array.length -1(即最后一个k出现在数组的最后一个位置)；

得到第一个k和最后一个k的下标后，只需将两个索引相减再加上1即可。

根据上面的描述，可写出如下代码

```java
package Chap6;

public class NumOfK {
    /**
     * 方法二：二分法找到第一个k和最后一个k，时间复杂度O(nlgn)
     */
    public int numberOfK(int[] array, int k) {
        if (array == null) return 0;
        int from = getFirstOfK(array, k, 0, array.length - 1);
        int to = getLastOfK(array, k, 0, array.length - 1);
        if (from == -1 && to == -1) return 0;
        else return to - from + 1;
    }
    // 找到第一个k的下标
    private int getFirstOfK(int[] array, int k, int low, int high) {
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (k < array[mid]) high = mid - 1;
            else if (k > array[mid]) low = mid + 1;
            else {
                if (mid > 0 && array[mid - 1] == k) high = mid - 1;
                else return mid;
            }
        }
        return -1;
    }
    // 找到最后一个k的下标
    private int getLastOfK(int[] array, int k, int low, int high) {
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (k < array[mid]) high = mid - 1;
            else if (k > array[mid]) low = mid + 1;
            else {
                if (mid < array.length - 1 && array[mid + 1] == k) low = mid + 1;
                else return mid;
            }
        }
        return -1;
    }
}
```

### 更巧妙的二分法

注意到要查找的数组元素都是int型的，我们知道普通二分查找只需稍微改变下返回值（返回low），就能得到一个排名方法——在数组中比k小的数有多少个，即k在数组中排名多少。有个很聪明的思路就是，在数组中查找接近k的浮点数。

```java
private int rank(int[] array, double k) {
    int low = 0;
    int high = array.length - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (k < array[mid]) high = mid - 1;
        else if (k > array[mid]) low = mid + 1;
    }
    // 和普通二分查找不同，从原来的-1改成返回low
    return low;
}
```

比如数组{1, 2, 3 ,3, 3, 3, 4, 5}中要查找3的个数。我们在数组中查找2.5，得到2.5在数组中的排名是2！同样在数组中查找3.5，得到3.5在数组中的排名是6。注意2.5和3.5之间夹的都是3！用这两个下标6 -2 = 4得到的刚好就是3的个数。

这是种很巧妙的方法，同样是O(lgn)的复杂度，这个方法的代码量少了很多。

```java
public int numOfK(int[] array, int k) {
    if (array == null) return 0;
    return rank(array, k + 0.5) - rank(array, k - 0.5);
}
```

### 题目2

> 0~n-1中缺失的数
> 一个长度为n -1的递增排序数组中的所有数字都是唯一的，并且每个数字的都在范围0~n-1之内。在范围内0~n-1内的n个数字中有且只有一个数字不在该数组中，找出这个数字

举个简单的例子来找到规律。比如数组长度为8，那么该数组中的数字都是0-8之间的，但是缺了一个数字，比如缺了4，则该数组为{0, 1, 2, 3, 5, 6, 7,8}

可以发现，缺失数字还没出现时，始终有**该数字在数组中的下标等于该数，即array[i] == i**,但是从5开始不再有这样的关系。对于5及其之后的元素有array[i] == i+1，但是5之前的3仍然有array[3] == 3, 可以看到这是一个分界线。此时返回5所在的下标4就是我们要的答案。

如果找到这个分界线呢？数组是有序的，仍然采用二分查找。当mid处满足array[mid] == mid，说明mid处及其之前的数都没有缺失，因此可以直接在mid右边数组查找；当array[mid] != mid说明mid处之前有元素丢失，此时再判断一下mid前的一个元素是否也有元素丢失，如果没有说明mid处是第一个值和下标不相等的元素，返回下标mid就是答案；如果mid处的前一个元素也有元素丢失，就继续缩小查找范围，在mid的左边数组继续查找即可。

根据上面的描述，写出如下代码：

```java
package Chap6;

public class FindTheLossNumber {
    public int findLoss(int[] array) {
        if (array == null) return -1;
        int low = 0;
        int len = array.length;
        int high = len - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (mid != array[mid]) {
                if (mid == 0 || mid -1 == array[mid -1]) return mid;
                else high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        if (low == len) return len;
        //  无效的输入数组，如不是递增排序，或者有的数字超出了0~n-1的范围
        return -1;
    }
}

```

注意上面还有句当mid != array[mid]时，如果mid == 0的情况，说明数组的第一个元素其下标就不等于值，很容易想到就是缺失了0，因此返回mid == 0也是正确的。这种情况也就是{1, 2, 3, 4, 5, 6,7,8} 缺少了0；

如果缺少的是0~n-1中的最后一位，即{0, 1, 2, 3, 4, 5, 6,7}, 此时缺少8，正好是数组的长度。这种情况最后会因为low = mid +1而使得low变成array.length，代码中也考虑到了，出了循环后判断了一下，此时返回array.length就是正确答案。

### 题目3

> 数组中数值和下标相等的元素。
> 假设一个单调递增的数组里的每个元素都是整数并且是唯一的。找出数组中任意一个数值等于其下标的元素。比如在数组{-3， -1， 1， 3， 5}，数字3和它的下标相等

又是递增数组，二分查找。

这次只需查找到array[mid] == mid就可以直接返回了，因为题目要求任意一个都行嘛。考虑array[mid] < mid的情况，由于数组有序，那么mid之前的元素同样有array[i] < i，这就是说我们不用考虑mid的左边数组，在右边数组查找即可；当array[mid] > mid时，由于数组有序，mid后面的元素都有array[i] > i, 因此不用考虑mid的右边数组，只在左边数组中查找即可。

听起来和普通的二分查找很像，实际上代码几乎一样。只是拿mid和array[mid]比较了，而不是某个要查找的k和array[mid]比较。

```java
package Chap6;

public class ValEqualsIndex {
    public int findValEqualsIndex(int[] array) {
        if (array == null) return -1;
        int low = 0;
        int high = array.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (mid > array[mid]) low = mid + 1;
            else if (mid < array[mid]) high = mid - 1;
            if (mid == array[mid]) return mid;
        }
        return -1;
    }
}
```

## 剑指offer面试题52--两个链表的第一个公共结点

> 输入两个单链表，找出它们的第一个公共结点。

这道题有一个隐含条件：单链表只有一个next指针，如果两个链表有公共结点，那么从第一个公共结点前的一个结点开始，两个链表的next都指向同一个结点了。通俗点说就是两条路汇聚成了一条。

### 两个链表，逆序比较

比如一条链表{1, 5, 6, 7, 8}另外一条{2, 3, 4, 5, 6, 7, 8}从结点5开始后面的结点都完全一样了。既然后面的结点完全一样，**我们可以从后往前比较两个链表当遇到某两个结点不同时，上次比较的结点就是逆序的最后一个公共结点了，即正序的第一个公共结点。**

为了可以从后往前比较两个结点，栈可以实现我们的想法。

```java
package Chap5;

import java.util.LinkedList;
    /**
     * 方法1：两个辅助栈，从尾到头，找到最后一个相同的结点
     */
    public ListNode findFirstCommonNodeStack(ListNode pHead1, ListNode pHead2) {
        ListNode cur1 = pHead1;
        ListNode cur2 = pHead2;
        LinkedList<ListNode> stack1 = new LinkedList<>();
        LinkedList<ListNode> stack2 = new LinkedList<>();
        // 分别存入两个栈中
        while (cur1 != null) {
            stack1.push(cur1);
            cur1 = cur1.next;
        }
        while (cur2 != null) {
            stack2.push(cur2);
            cur2 = cur2.next;
        }
        // 用于记录逆序的上一个公共结点
        ListNode publicNode = null;
        while (!stack1.isEmpty() && !stack2.isEmpty()) {
            if (stack1.peek() == stack2.pop()) publicNode = stack1.pop();
                // 当前比较的不相同时，返回逆序的最后一个公共结点（也就是正序的第一个公共结点）
            else return publicNode;
        }
        return publicNode;
    }
```

假设链表1的长度为m，链表2的长度为n，那么这种方法的时间复杂度为O(m+n)，但相应地需要额外空间。

### 利用集合不能添加重复元素的特性

说到使用额外空间，使用Set可以轻松找出第一个公共结点。所谓公共结点其实就是完全一样的元素，**而Set不能存入相同元素，当第一次添加元素失败时，该结点就是第一个公共结点了。**

```java
package Chap5;

import java.util.HashSet;
import java.util.Set;

public class FirstPublicNode {
    /**
     * 还可以用Set，先存入第一个链表的所有结点，然后存入第二个链表的结点，当第一次添加失败的时候说明发现了第一个重复结点
     */
    public ListNode findFirstCommonNodeSet(ListNode pHead1, ListNode pHead2) {
        Set<ListNode> set = new HashSet<>();
        ListNode cur1 = pHead1;
        ListNode cur2 = pHead2;
        while (cur1 != null) {
            set.add(cur1);
            cur1 = cur1.next;
        }

        while (cur2 != null) {
            if (!set.add(cur2)) return cur2;
            cur2 = cur2.next;
        }
        return null;
    }
}

```

### 不使用额外空间的方法

因为第一个公共结点及其之后的结点都相同，所以我们可以将两条链表的**尾部对齐**

，但是两条链表的长短可能不一样。这就需要长链表先走若干步，然后两条链表一起走，知道遇到一个相同结点，该结点就是第一个公共结点。具体长链表要先多少步，当然是长短链表长度之差。所有需先遍历一遍链表得到两个链表的长度。

```java
package Chap5;

public class FirstPublicNode {
    /**
     * 方法2：先得到两个链表的长度；
     * 让两个链表的尾部对齐，即先让长链表走若干部，然后两个链表同时走，保证它俩同时到链表末尾
     */
    public ListNode firstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode cur1 = pHead1;
        ListNode cur2 = pHead2;
        int len1 = 0;
        int len2 = 0;
        // 计算链表1的长度
        while (cur1 != null) {
            len1++;
            cur1 = cur1.next;
        }
        // 计算链表2的长度
        while (cur2 != null) {
            len2++;
            cur2 = cur2.next;
        }
        // 长链表先走若干步，和短链表的尾部对齐
        if (len2 > len1) {
            for (int i = 0; i < len2 - len1; i++) pHead2 = pHead2.next;
        }

        if (len1 > len2) {
            for (int i = 0; i < len1 - len2; i++) pHead1 = pHead1.next;
        }
        // 同时前进，第一个相等的结点即是
        while (pHead1 != null && pHead2 != null) {
            if (pHead1 == pHead2) return pHead1;
            pHead1 = pHead1.next;
            pHead2 = pHead2.next;
        }
        return null;
    }
}

```

上面几种方法的时间复杂度都是O(m+n)，但是这种方法不需要额外空间，更好。

### 很短的代码

下面看别人写的代码，总之就是两个指针p1和p2在两个链表之交替着走：p1如果没走到末尾就前进一步，走到末尾就转向链表2，从头结点开始接着走；对于p2也是如此。

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    ListNode p1 = pHead1;
    ListNode p2 = pHead2;
    while (p1 != p2) {
        p1 = (p1 == null ? pHead2 : p1.next);
        p2 = (p2 == null ? pHead1 : p2.next);
    }
    return p1;
}
```

具体来说，如果确实有公共结点，设链表1是由a + n两部分组成，a是非公共结点部分，n是公共结点部分；相应的链表2由b+ n组成。如果两个链表长度一样，p1和p2同时走，不到一次遍历就可找出公共结点。

如果长度不一样，假设a +n < b+ n。此时p1先到末尾，p2还有b - a到末尾。之后p1转到链表2的头结点，p2走b-a也到达末尾转入链表1的头结点，p1因为也走了b-a步，所以当p2走到链表1的头结点时，此时p1和p2两个指针对齐了，这样同时走，就能在第一个公共结点处相遇；

如果没有公共结点，那么最后两个指针都是null也会退出循环并返回null。

## 剑指offer面试题53--数组中的逆序对

> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数.

暴力法很直观，拿第一个数和之后的每个数比较，然后拿第二个数和之后的每个数比较.....需要两个for循环可得到结果，时间复杂度为$O(n^2)$

用数组的归并过程来分析这道题，归并排序就是自上而下地将数组分割成左右两半子数组，然后递归地将子数组不断分割下去，最后子数组的大小为1，对于大小为1的子数组没有排序和归并的必要，因此递归到此结束；之后自下而上地对这若干个子数组两两归并、四四归并......每次归并后左右子数组都分别有序，最后再将整个数组归并，因而整个数组也有序了。

现在分析一个简单的例子，对于数组{7, 5, 6, 4}，先分成了两个子数组，左子数组{7, 5}和右子数组{6, 4}，进而分成左子数组{7}和右子数组{5}....7大于5，所以这是一个逆序对，同样6大于4也是一个逆序对。现在得到两个逆序对了。然后开始两两归并，左子数组和右子数组现已分别排序，{5, 7}和 {4, 6}，**因为大的数在右边，所以考虑从右边开始比较**。比如7大于6，那么7肯定也大于4，所以如果左边某个数p1比右边某个数p2大了，p1无需再和p2之前的所有数进行比较，这就减少了比较次数。那么在右子数组中比7小的有多少呢？多举几个例子就能发现通用的公式：**p2及其之前的元素个数减去左子数组的长度。**要求整个数组的逆序对总数，只需将每个子数组中的逆序对个数累加即可。

理解上述分析后，其实本题就可以直接使用归并排序，只是在左子数组中的某个元素大于右子数组某个元素时，多加一步——计算逆序对个数即可。

```java
package Chap5;

public class InversePairs {
    public int inversePairs(int[] array) {
        if (array == null) return 0;
        int[] aux = new int[array.length];
        return sort(array, aux, 0, array.length - 1);
    }

    private int sort(int[] array, int[] aux, int low, int high) {
        if (high <= low) return 0;
        int mid = low + (high - low) / 2;
        int left = sort(array, aux, low, mid);
        int right = sort(array, aux, mid + 1, high);
        int merged = merge(array, aux, low, mid, high);
        return left + right + merged;
    }

    private int merge(int[] array, int[] aux, int low, int mid, int high) {
        int count = 0;
        int len = (high - low) / 2;
        int i = mid;
        int j = high;

        for (int k = low; k <= high; k++) {
            aux[k] = array[k];
        }

        for (int k = high; k >= low; k--) {
            if (i < low) array[k] = aux[j--];
            else if (j < mid + 1) array[k] = aux[i--];
            else if (aux[i] > aux[j]) {
                // 在归并排序的基础上，在这里求count
                count += j - low - len;
                array[k] = aux[i--];
            } else array[k] = aux[j--];
        }
        return count;
    }
}

```

关键就是merge方法，和传统的归并排序相比，有了返回值，在`aux[i] > aux[j]`时多了一句`count += j - low - len;`以计算逆序对的个数。**j - low得到p2及其之前元素的个数，len表示左子数组的大小，按上面的分析，这个值就是逆序对的个数。**

我们知道归并排序的时间复杂度是$O(nlgn)$，但是需要O(n)的空间，所以这是个那空间换时间的例子。

## 剑指offer面试题54--二叉搜索树中排名为k的结点

> 给定一颗二叉搜索树，请找出排名第k的结点。

注意是二叉搜索树，这说明对于任何结点，有父结点大于其左子结点且小于右子结点。**如果中序遍历这棵树，就能得到递增排序的序列。**

接下来就很简单了，只需中序遍历到第k个结点，然后立即返回就行了。感觉对于这道题，非递归的中序遍历更好写一点。

```java
package Chap6;

import java.util.LinkedList;

public class KthNode {
    public TreeNode findKthNode(TreeNode pRoot, int k) {
        if (pRoot == null || k <= 0) return null;
        LinkedList<TreeNode> stack = new LinkedList<>();
        int count = 0;
        while (pRoot != null || !stack.isEmpty()) {
            while (pRoot != null) {
                stack.push(pRoot);
                pRoot = pRoot.left;
            }
            if (!stack.isEmpty()) {
                pRoot = stack.pop();
                // 一个计数器，遍历到第k个就立即返回
                if (++count == k) return pRoot;
                pRoot = pRoot.right;
            }
        }
        return null;
    }
}
```

## 剑指offer面试题55--二叉树的深度

> 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

### 二叉树的深度-递归版本

很容易想到使用递归，根结点处的深度为1，既然要求树的最长路径，必然从根结点的左右子树中选出深度更大的那棵子树，也就是整棵树的深度为

$$depth(root) = max[depth(root.left), depth(root.right)] + 1$$

加1是因为要加上树的根结点。那么对于每棵子树，也要按照这样的规则——挑选出深度更大的子树并加上1，也就得到了以当前结点为根结点的二叉树的深度。这是个递归结构。

```java
/**
 * 递归版本
 */
public int TreeDepth(TreeNode root) {
    if (root == null) return 0;
    int left = TreeDepth(root.left);
    int right = TreeDepth(root.right);
    return Math.max(left, right) + 1;
}
```

当递归自上而下深入到叶子结点的孩子结点（null）时，返回0，从而会得到叶子结点的深度为1，就这样自底向上返回，每次回到上一层都是下一层的最大深度加上1，直到根结点......

这个代码也可以看成是后序遍历，先访问了父结点的左右子结点，从中选出深度更大着，然后回到父结点时加1（也就是算上父结点后深度会增加1）。

### 二叉树的深度-非递归版本

求深度，其实就是求这棵二叉树有多少层。于是采用BFS的层序遍历。关键就是怎么知道什么时候处理完了二叉树的一层？我们来模拟一下：

就假设这是棵满二叉树吧，根结点先入队列，此时队列中结点个数为1，接着会弹出这唯一的根结点，同时入列两个结点，此时第一层处理完毕；

现在队列中结点个数为2，我们出列两次，4个结点又会入列，此时第二层处理完毕；

现在队列中结点个数为4，我们出列4次，8个结点又会入列，此时第三层处理完毕....

发现规律了吗？**每次要出列前，先得到队列中现有的结点个数，假设是m，那么就在循环内出列m次，随即跳出循环，这样就算处理完一行了。**跳出循环后只需要将深度自增，最后层序遍历完毕也就得到了二叉树的深度。

```java
/**
 * 非递归，层序遍历
 */
public int depth(TreeNode root) {
    if (root == null) return 0;
    Queue<TreeNode> queue = new LinkedList<>();
    int depth = 0;
    queue.offer(root);
    while (!queue.isEmpty()) {
        int layerSize = queue.size();
        for (int i = 0; i < layerSize; i++) {
            TreeNode node = queue.poll();
            if (node.left != null) queue.offer(node.left);
            if ((node.right) != null) queue.offer(node.right);
        }
        depth++;
    }
    return depth;
}
```

### 二叉树的深度-平衡二叉树

> 输入一棵二叉树，判断该二叉树是否是平衡二叉树。

本题应该是假定输入的已经是二叉搜索树，因为平衡二叉树首先是一颗二叉搜索树。平衡二叉树的定义是：对于任意结点，其左右子树的深度相差不超过1。

### 利用上题的函数

有了上面求二叉树深度的基础，这道题就很容易写出如下的递归解法。

先从根结点开始求得其左右子树的深度，然后做差，如果深度差超过1，那这不是棵平衡二叉树；切不可以为根结点的左右子树深度差不超过1，下面的子树深度差就不会超过1了，画几幅反例就知道了。所以递归地对左右子树也做同样的判断是必须的，以确保每个以结点为根结点其左右子树的深度差不超过1。

```java
package Chap6;

public class BalancedTree {
    /**
     * 方法1：递归地求每个结点的左右子树深度差，有重复计算
     */
    public boolean isBalancedTree(TreeNode root) {
        if (root == null) return true;
        int left = depth(root.left);
        int right = depth(root.right);
        if (Math.abs(left - right) > 1) return false;
        return isBalancedTree(root.left) && isBalancedTree(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        int left = depth(root.left);
        int right = depth(root.right);
        return Math.max(left, right) + 1;
    }
}
```

这种方法有个缺点，多个结点会被重复访问。

### 修改求二叉树深度的方法

仍然是先求得左右子树的深度，如果做差不超过1，就正常返回深度；如果超过了1就说明这不是棵平衡二叉树了，于是不断返回-1，直到根结点。如果不是平衡二叉树，最后会得到该二叉树的深度为-1，所以只需判断一棵二叉树的深度是不是大于等于0即可。

```java
/**
 * 方法2：修改求二叉树深度的方法：
 * 只要有某个结点不平衡，将一直返回-1直到root；否则就正常返回树的深度
 */
public boolean isBalanced(TreeNode root) {
  return depth2(root) >= 0;
}

private int depth2(TreeNode root) {
    if (root == null) return 0;
    int left = depth2(root.left);
    int right = depth2(root.right);
    return left >= 0 && right >= 0 && Math.abs(left - right) <= 1 ? Math.max(left, right) + 1 : -1;
}
```

不得不说这是个很巧秒的方法，推荐。

### 书上的方法--后序遍历

之所以使用后续遍历，是因为后续遍历先访问父结点的左右子结点后，再访问父结点的，因此这种遍历顺序可以先得到左右子结点深度之差，然后再回到当前父结点求得父结点的深度...就这样自底向上判断每个结点的左右子树深度差，有某一个结点不平衡都将导致不断返回false。

需要一个指针记录当前结点的深度，而int型不是对象只能传值，为了传引用那就建立一个长度为1的对象数组吧，和前面说过的一样，当到达叶子结点的做右子结点（null）时深度为0，那么返回到叶子结点深度为1 ...

```java
package Chap6;

public class BalancedTree {
    /**
     * 方法3：后序遍历，为了传引用使用了对象数组
     */
    public boolean IsBalanced_Solution(TreeNode root) {
        return isBalance(root, new int[1]);
    }

    public boolean isBalance(TreeNode root, int[] depth) {
        if (root == null) {
            depth[0] = 0;
            return true;
        }
        boolean left = isBalance(root.left, depth);
        // 左子树的深度
        int leftDepth = depth[0];
        // 右子树的深度
        boolean right = isBalance(root.right, depth);
        int rightDepth = depth[0];
        // 当前结点的深度
        depth[0] = Math.max(leftDepth + 1, rightDepth + 1);
        if (left && right && Math.abs(leftDepth - rightDepth) <= 1) return true;
        return false;
    }
}
```

## 剑指offer面试题56--数组中数字出现的次数

> 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
> 要求时间复杂度为O(n)，空间复杂度为O(1).

例如输入数组{2, 4, 3, 6, 3, 2, 5, 5},只有4和6这两个数字只出现了一次，其他数字都出现了两次，因此输出4和6。

如果不考虑空间，用哈希表统计频率倒是很简单.....

好吧，没有思路。书中使用的是位运算。

先考虑简单的情况，如果数组中只有一个数字出现了一次而其他数都出现了两次。那么堆数组中的每个数都做异或运算，因为两个相同的数每一位都相同，因此他们异或值为0，所有最后得到的结果就是那个只出现了一次的数。

现在只出现了一次的数有两个，只需要将这两个数分开，使得其中一个数在一个子数组中，另外一个数在另一个子数组中，再使用上面的方法即可。

由于有两个只出现了一次的数，对数组中所有数异或，得到的将是那两个只出现了一次的数的异或值。

就以上面的例子来说，最后会得到4和6的异或值，即100和110的异或值010（省略了前面29个0，因为int型是32位的），可以看到从右往左数的第2位是1，说明4和6在从右往左数的第2位不一样。**在异或结果中找到第一个1的位置，假设是m（这说明那两个只出现了一次的数的第m位一个是1一个是0）。现在以第m位是不是1为标准将数组分成两部分，出现过两次的数一定会被分到同一个部分中，因为他们每一位都相同，第m位当然也相同；只出现过一次的两个数一定会被分到不同的部分中。**

对这两部分分别异或，每一部分就得到了那么只出现了一次的数。

```java
package Chap6;

public class FindNumsAppearOnce {
    //num1,num2分别为长度为1的数组。传出参数
    //将num1[0],num2[0]设置为返回结果
    public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
        if (array == null || array.length < 2) return;
        int res = 0;
        // 这步得到两个只出现一次的数的异或值
        for (int i = 0; i < array.length; i++) {
            res ^= array[i];
        }
        // res肯定不为0，那么res必然有某一位是1，找到第一个1的索引，假设为n;
        // 第n位的异或值为1，也说明了这两个数的第n位不相同
        int indexOfFirstOne = firstBitOfOne(res);
        // 以第n位是不是1为标准，将数组拆分成两个
        // 相同数字一定会被分到同一个子数组，因为相同的数字第n位也是相同的；只出现一次的那两个数字肯定不会分到一个数组中，因为他们的第n位异或值为1，说明他们第n位不相同
        for (int i = 0; i < array.length; i++) {
            if (isBitOfOne(array[i], indexOfFirstOne)) num1[0] ^= array[i];
            else num2[0] ^= array[i];
        }
    }

    /**
     * 找到从右往左数的第一个1的索引，如0110的第一个1索引为1
     */
    private int firstBitOfOne(int val) {
        int index = 0;
        while (val != 0) {
            if ((val & 1) == 1) return index;
            val = val >> 1;
            index++;
        }
        return -1;
    }

    /**
     * 判断从右往左数的第index位是不是1
     */
    private boolean isBitOfOne(int val, int index) {
        val = val >> index;
        return (val & 1) == 1;
    }
}

```

### 数组中数字出现的次数-相关题目

> 数组中唯一出现一次的数字。
> 在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次，请找出那个只出现一次的数字.

使用排序需要O(nlgn)的时间，使用哈希表需要O(n)的空间。有没有更好的？

一个int型有32位，每一位不是0就是1。对于三个相同的数，统计每一位出现的频率，那么每一位的频率和一定能被3整除，也就是说频率和不是3就是0。如果有多组三个相同的数，统计的结果也是类似：频率和不是0就是3的倍数。

现在其中混进了一个只出现一次的数，没关系也统计到频率和中。如果第n位的频率和还是3的倍数，说明只出现一次的这个数第n位是0；如果不能被3整除了，说明只出现一次的这个数第n位是1。由此可以确定这个只出现一次的数的二进制表示，想得到十进制还不简单吗。

```java
package Chap6;

public class AppearOnlyOnce {
    public int findNumberAppearOnlyOnce(int[] numbers) {
        if (numbers == null || numbers.length == 0) throw new RuntimeException("无效输入");
        int[] bitSum = new int[32];
        int bitMask = 1;
        // 注意先对最低位做位运算，bitSum[0]存的最高位，bitSum[31]存的最低位
        for (int i = 31; i >= 0; i--) {
            for (int number : numbers) {
                int bit = number & bitMask;
                if (bit != 0) bitSum[i] += 1;
            }
            bitMask = bitMask << 1;
        }
        int result = 0;
        // 转换成十进制时，从最高位开始，从由左至右第一个不为0的位开始
        for (int i = 0; i < 32; i++) {
            result = result << 1;
            // bitSum[i] % 3为0说明只出现一次的那个数第i为也是0；反之亦反
            result  += bitSum[i] % 3;
        }
        return result;
    }
}
```

要注意的一点是，统计每一位的频率时，是从最低位开始的，bitSum[31]存的是最低位的频率和，而bitSum[0]存的是最高位的频率和，这和人从左往右的阅读习惯一致。从二进制转换成十进制时，则是从最高位开始的，从由左至右第一个不为0的位开始累加，最后得到该数的十进制表示，返回即可。

该方法只需要O(n)的时间，空间复杂度为O(1)。

## 剑指offer面试题57--和为s的数字

### 和为s的数字-题目1

> 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S；如果有多对数字的和等于S，输出两个数的乘积最小的。

先看这个条件：和一样，要求乘积最小。由于数组递增排序，那么这两个数与其他和为s的两个数比，相隔的距离更远。这里就不证明了，试想周长一样的两个图形，又扁又长的矩形和正方形比哪个面积大吧....

要从数组中找两个数相加，如果和刚好为s，这样就找到了一组候选值；如果和小于s呢，可以把两个数中较小者丢弃，换一个比它稍大的继续求和与s比较;如果和大于s就丢弃较大值换一个比该值稍小的，继续求和与s比较。由于数组已经排序，要换比较小值稍大的，或者换比较大值稍小的都不是难事。

**设置两个指针，一个指向数组的第一个元素，另一个指向数组的最后一个元素。即一开始将较小值设为数组的最小值，较大值设置为数组的最大值。**

接下来求按照上面的方法不断与s比较，找到第一组和为s的两个数就是乘积最小的。

举个例子{1, 2, 4, 7, 11, 15}和数字15，刚开始1+15大于15，所以丢弃15；将1和11求和，小于15，所以丢弃1；将2和11求和，小于15，丢弃2；将4和11求和，刚好等于15，找到第一组和为15的两个数是4和11，它们乘积就是最小的。

```java
package Chap6;

import java.util.ArrayList;

public class TwoSum {
    public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
        ArrayList<Integer> list = new ArrayList<>();
        if (array == null || array.length <= 1) return list;

        int low = 0;
        int high = array.length - 1;

        while (low < high) {
            if (array[low] + array[high] == sum) {
                list.add(array[low]);
                list.add(array[high]);
                break;
            } else if (array[low] + array[high] > sum)
                high--;
            else low++;
        }
        return list;
    }
}

```

代码中只有一个循环，从两头向中间扫描数组，因此时间复杂为O(n)

### 和为s的数字-题目2

> 和为s的连续正数序列。
> 输入一个正数s，打印出所有何为s的连续正数序列（至少含有两个数）。
> 例如输入15，由于1+2+3+4+5 = 4+5+6 = 7+8,所有打印出三个连续的序列1~5,4~6,7~8

注意因为是连续的正数序列，所以序列至少是从1开始的。题目要求至少含有两个数，不妨假设一开始序列中是两个最小的值，即1和2。

举个例子假设s等于9。对初始序列求和得到3，如果小于9，说明需要扩大序列使它包含更多数字，那就增加一个数字，现在序列变成{1,2, 3}，对序列求和继续和9比较，还小了，那就再增加一个数字序列变成{1, 2, 3 ,4}，这次序列和比9大了，丢弃序列中的最小值，现在序列变成{2, 3, 4}，序列求和刚好等于9！因此{2, 3, 4}是一个满足条件的序列，继续找。满足条件的其他序列肯定在后面，所以此时需要扩大序列，因此增加一个数字序列变成{2,3,4,5}, 序列和比9大，**不断丢弃最小值直到序列和小于等于9**，因此丢弃2、丢弃3，现在剩下{4, 5}，序列和和9相等，又找到一个！后面还有没有满足条件的序列呢？**注意到序列是递增的，而且满足条件的序列至少有两个数。**那么满足条件的序列中最大的数不会⌈s / 2⌉了，因为5之后是6，加起来超过9了，所以从5开始其后的序列都不可能满足条件。

```java
package Chap6;

import java.util.ArrayList;

public class ContinuousSeq {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
        ArrayList<ArrayList<Integer>> list = new ArrayList<>();
        if (sum <= 2) return list;
        int small = 1;
        int big = 2;
        int curSum = small + big;
        int mid = (sum + 1) / 2;
        while (small < mid) {
            while (curSum > sum && small < mid) {
                curSum -= small;
                small++;
            }
            if (curSum == sum) list.add(addFromSmallToBig(small, big));
            big++;
            curSum += big;
        }
        return list;
    }

    /**
     * 对一个连续区间内的数字求和
     */
    private ArrayList<Integer> addFromSmallToBig(int small, int big) {
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = small; i<= big; i++) {
            list.add(i);
        }
        return list;
    }

    public static void main(String[] args) {
        ContinuousSeq continuousSeq = new ContinuousSeq();
        System.out.println(continuousSeq.FindContinuousSequence(9));
    }
}
```

因为每次只是在序列尾部增加一个数字或者在序列头部丢弃一个数字，所以使用了一个curSum可以很方便地保存当前序列的和。

当序列和小于s，或者序列和等于s两种情况下都需要扩大序列使其包含更多的数。所以先用while循环判断序列和大于s的情况（此时small在自增所以还要保证small要小于mid），直到序列和小于或者等于s才退出循环；接在再判断序列和是否等于s，不管等不等于s，扩大序列的代码都会得到执行，这就很好地综合了两种情况，节省了代码量。
