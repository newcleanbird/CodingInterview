# 第5章-优化时间和空间效率

## 剑指offer面试题42--连续子数组的最大和

>输入一个整型数组，数组里正负数都可能有，数组中的一个或者连续的多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为O(n)

枚举所有的子数组，从中选择最大和可能是很容易想到的办法了，但是总共有$n(n+1) /2$个子数组，最快也需要$O(n^2)$时间复杂度，Pass。

我们可以举例分析数组的特点比如{1, -2, 3, 10, -4, 7, 2, -5}。首先记录下第一个元素，先假设它为最大和。当1加上-2时变成了-1，再加上3等于2，3前面加了一堆还不如不加，所以应该直接从3开始加，即**如果当前累加和是负数，那么它加上当前元素将使得新的累加和比当前元素还要小，此时应该将之前的累加和丢弃，从当前元素开始累加。**

按照上述方法，新的累加和为3大于当前最大和，因此最大和更新为3；加10，当前最大和变成13，继续-4，当前累加和为9，并不大于当前最大和，因此最大和不更新；加7、加2，当前和为18，大于最大和，当前最大和更新为18；最后-5，当前累加和为13，不大于最大和18。遍历完毕，返回最大和18.如果搞清楚了上面的思路，可以很容易写出如下代码:

```java
package Chap5;

public class FindGreatestSumOfSubArray {
    public int findGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0) return 0;

        int maxSum = array[0];
        int curSum = array[0];
        for (int i = 1; i < array.length; i++) {
            // 丢弃累结合，从当前元素开始累加
            if (curSum < 0) curSum = array[i];
            // 累加
            else curSum += array[i];
            // 和当前最大和比较，若比它大就更新
            if (curSum > maxSum) maxSum = curSum;
        }
        return maxSum;
    }
}

```

没几行，只需遍历一次，时间复杂度为O(n).

### 动态规划

还可以用动态规划的思想，用$f(i)$表示以第i个数字结尾的子数组，其中$0 \le i < n $，那么我们要求的就是$max[f(i)]$。

$$f(i) = array[i], i=0 或者f(i-1) < 0$$

$$f(i) = f(i -1) + array[i], i \neq 0 且f(i -1) \ge 0$$

**动态规划最重要的就是要保存中间计算结果**，这里$f(i)$其实就是上面的curSum，$max[f(i)]$的计算变成了两两比较，其实就是上面的maxSum。可以看到和上面的方法是异曲同工的。这里保存的中间计算结果就是curSum和maxSum，当$f(i-1) < 0$时对应着上面curSum < 0. 否则就累加，然后求$max[f(i)]$可以通过两两比较得到最终的最大和，也就是$f(i)$和当前的max比较选择较大的那个。

```java
package Chap5;

public class FindGreatestSumOfSubArray {
    /**
     * 动态规划，其实和上面是一样的代码...
     */
    public int FindGreatestSumOfSubArray2(int[] array) {
        if (array == null || array.length == 0) return 0;

        int maxSum = array[0];
        int curSum = array[0];
        for (int i = 1; i < array.length; i++) {
            // if (curSum + array[i] < array[i]),也就是if (curSum < 0) 则curSum的结果是array[i]
            // 否则curSum的值是curSum + array[i]
            curSum = Math.max(curSum + array[i], array[i]);
            // 如果curSum > maxSum,则maxSum取curSum，否则maxSum = maxSum
            maxSum = Math.max(curSum, maxSum);
        }
        return maxSum;
    }
}
```

## 剑指offer面试题43--1~n整数中1出现的次数

>输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数，例如输入12, 1~12中出现1的有1、10、11、12共5次

### 计算每个数字出现1的次数

比较直接的思路就是写一个方法可以统计任意整数1的个数，然后用一个循环得到对1~n每一个数调用该方法统计总的1的出现次数。

```java
package Chap5;

public class NumOf1 {
    /**
     * 方法1，计算每个数字中1的个数，复杂度O(nlgn)
     */
    public int NumberOf1From1To(int n) {
        // 正负数不影响1的个数，统一变成非负数
        if (n < 0) n = Math.abs(n);

        int count = 0;
        // 循环求n个数字，共O(nlgn)的时间
        for (int i = 1; i <= n; i++) {
            count += numOf1(i);
        }
        return count;
    }

    /**
     * O(lgn)的复杂度求一个数中含有1的数量
     */
    private int numOf1(int n) {
        int count = 0;
        while (n != 0) {
            if (n % 10 == 1) count++;
            n = n / 10;
        }
        return count;
    }
}

```

`numOf1`方法中，n % 10可以得到个位，n = n / 10表示丢弃最低位。该方法的复杂度为O(lgn)，对于1~n中n个数字都要调用一遍该方法，总的时间复杂度是O(nlgn)。

### 更暴力的解法--StringBuilder拼接

使用StringBuilder将1~n的所有数无缝拼接起来，然后一个个数。

```java
package Chap5;

public class NumOf1 {
    /**
     * 方法2：使用StringBuilder将所有数字拼接，无脑数数
     */
    public int numOf1Between1AndN(int n) {
        // 正负数不影响1的个数，统一变成非负数
        if (n < 0) n = Math.abs(n);

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append(i);
        }

        int count = 0;
        for (int i = 0; i < sb.length(); i++) {
            if (sb.charAt(i) == '1') {
                count++;
            }
        }
        return count;
    }
}
```

### 神一样的方法

参考[LeetCode](https://discuss.leetcode.com/topic/18054/4-lines-o-log-n-c-java-python)

1可以出现在任意一位，比如3245，1出现在个、十、百、千位都可以。只要固定某一位为1，计算出该位是1的所有情况，将固定每一位得到的情况数相加就是最终结果。

要固定某一位为1，可以使用m = 1, 10, 100, 1000....，对n作除、余操作，将输入整数分为高位和低位两部分。举个例子，对于输入n = 3101592，m = 100，如果令a = n / m, b = n % m，将得到a = 31015，b= 92两部分，现在固定百位为1（始终固定a的最低位），即`xxxx1xx`这样的形式，这样形式的数有多少个呢？

```s
0000 1 00
0000 1 01
.....
0000 1 99
0001 1 00
......
0001 1 99
0002 1 00
......
0002 1 99
......
3101 1 00
......
3101 1 99
```

为了看得直观，上面刻意将数字从百位处分隔开，对于百位之前的高位数，总共有`0000~3101`共3102种情况，而每一种情况对应着低位有`00~99`共100种情况，因此百位为1的情况数是3102*100，也就是`(a / 10 + 1) * m`种情况。好，现在得到百位为1的情况数了，个位与千位等其他位计算方法和上面类似，只需取不同的m就能将输入的整数分成两部分并固定某一位为1.

接下来m = 1000时，3101592被分成a = 3101和b = 592两部分，现在固定千位为1，但是此时千位本来就是1了，来看和上面有什么不同

```s
000 1 000
......
000 1 999
309 1 000
......
309 1 999
310 1 000
......
310 1 592
```

可以看到千位前的高位从`000~309`和上面一样，每一种情况都有`000~999`种可能，但是到310时，后面最多只能到592，共`000~592`是593种情况。此时千位为1的情况总数为：310 * 1000 + 593，即**当前要被固定的位在输入中本来就是1**的话有`(a / 10) * m + b + 1`种情况。

再看m = 10000，固定万位的情况。a = 310, b = 1592.

```s
00 1 0000
......
00 1 9999
30 1 0000
......
30 1 9999
```

没有了，共31 * 10000种，即**当前要被固定的位在输入中是0**的话有`(a / 10) * m`种情况。

一开始固定百位其实就是**当前要被固定的位在输入中是2~9**这种情况。

分析得差不多了，现在考虑这三种情况计算就好了。

```java
/**
 * 方法三
 */
public int numberOf1(int n) {
    int ones = 0;
    for (long m = 1; m <= n; m *= 10) {
        long a = n / m;
        long b = n % m;
        if (a % 10 == 0) ones += a / 10 * m;
        else if (a % 10 == 1) ones += (a / 10 * m) + (b + 1);
        else ones += (a / 10 + 1) * m;
    }
    return ones;
}
```

## 剑指offer面试题44--数字序列中的某一位数字

>数字以0123456789101112131415....的格式序列化得到一个字符序列中，在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字

### 逐个列举

有一种方法，每列举一个数字就记录当前序列长度和，比如列举到3，序列的长度和为4，列举到10，长度和为12...以此类推。当某次列举使得当前长度和大于给定的n时，停止列举，**第n位数一定在在刚列举的数中**，接下里只需从这个数中找出是哪一位即可。

```java
package Chap5;

public class ADigitInNumberSeq {
    /**
     * 方法1：逐个列举
     */
    public int numAtSeq(int index) {
        if (index < 0) return -1;

        int i = 0;
        int sum = 0;
        while (true) {
            sum += countDigits(i);
            // 一定不要包含=
            if (sum > index) break;
            i++;
        }
        // sum - n是超出的部分，减去1是因为下标从0开始
        return digitAt(i, sum - index - 1);
    }

    /**
     * 返回某数的第d位, 第0位是个位，第1位是十位，以此类推
     */
    private int digitAt(int value, int d) {
        return (value / (int) Math.pow(10, d)) % 10;
    }

    /**
     * 计算某数有多少位
     */
    private int countDigits(int num) {
        if (num == 0) return 1;

        int count = 0;
        while (num != 0) {
            num /= 10;
            count++;
        }
        return count;
    }
}

```

当前长度和sum > index时候退出循环，此时第index位一定在数字i中，那到底是数字i的第几位呢？举个例子

```s
012345678910111213...
```

找index = 16的数，当列举到13时候，当前长度和sum = 18 > 16，此时i = 17，容易得知index位是1，即17的第0位。多举几个例子就容易发现只要取数字`i`的第`sum - index -1`位就是我们要找的数字。

### 更快的方法

从数字本身的规律入手。如果要找第1001位，肯定不会考虑0~9折十位吧？接下来10-99也就有180位而已，不考虑，每次不考虑的情况需要减去已缩小查找范围，因此在排除掉0-99共180+10后还剩881，也就是说我们原来是从0开始找到第1001位，现在只需从100开始找到第991位即可。接下来看100-999共2700位，由于881  < 2700，所以这个数必然在100~999的范围内。881 = 270 * 3 + 1，说明这个数是100开始之后的第270个数的第1位（从0开始计算索引），也就是370的第一位数，即7。

有了思路后，要实现几个关键的方法，首先是根据位数得到一个区间的开始数字。区间划分为：0-9， 10-99， 100-999...比如n = 1，一位数的开始数是0; n = 2,两位数的开始数是10; n = 3,三位数的开始数是100...

其次因为要缩小查找范围，所以要根据位数知道该范围内总共有多少个数字，比如n = 1, 一位数0-9的范围共10个数；n = 2，两位数10-99的范围共90个数；n = 3，三位数100-999的范围共900个数....

还需要一个方法，一旦锁定范围，根据当前的位数能知道包含index处数字的数是几，然后从该数中找到要求的那位。

 ```java
package Chap5;

public class ADigitInNumberSeq {
    /*****************************************
     * 方法2
     */
    public int numAtSeq2(int index) {
        if (index < 0) return -1;
        // 位数，digits = 1表示一位数，0-9区间；digits = 2表示两位数，10-99区间...
        int digits = 1;
        while (true) {
            int numbers = numOfRange(digits);
            // 范围锁定，numbers * digits表示该区间共有多少位数字，如digits = 2，范围10-99就有180位
            if (index < numbers * digits) {
                return digitAt2(index, digits);
            }
            // 缩小范围
            index -= numbers * digits;
            digits++;
        }
    }

    /**
     * 根据位数得到范围内的个数，比如1位，0~9共10个
     * 2位，10~99共90个
     * 3位，100~999共900个
     * ...
     */
    private int numOfRange(int n) {
        if (n == 1) return 10;

        return (int) (9 * Math.pow(10, n - 1));
    }

    /**
     * n位数范围内的的第一个数，比如1位数，0~9，第一个是0
     * 2位数，10~99，第一个数是10
     * 3位数，100~199，第一个数是100
     */
    private int beginNumber(int n) {
        if (n == 1) return 0;
        return (int) Math.pow(10, n - 1);
    }
    // 锁定范围后，根据位数就能得到包含index处那位数的数字，然后从该数中找到要求的那位 
    private int digitAt2(int seqIndex, int digits) {
        int number = beginNumber(digits) + seqIndex / digits;
        return digitAt(number, digits - seqIndex % digits - 1);
    }

    public static void main(String[] args) {
        ADigitInNumberSeq a = new ADigitInNumberSeq();
        System.out.println(a.numAtSeq(1001)); // 7
        System.out.println(a.numAtSeq2(1001)); // 7
    }
}

 ```

重点看`digitAt2`方法

```java
private int digitAt2(int seqIndex, int digits) {
    int number = beginNumber(digits) + seqIndex / digits;
    return digitAt(number, digits - seqIndex % digits - 1);
}
```

`seqIndex / digits`表示该区间开始数字其后多少位是我们要找的数字，再加上`beginNumber(digits)`就得到了我们要找的数字，比如上面的例子811 / 3 = 270，说明是开始数字100其后的270位，于是我们知道了这个数是370，接下来`seqIndex % digits`取余操作可以得到数是370第1位，**由于得到的余数是从左往右数的，而digitAt方法是从右往左数的**。因此取`digits - seqIndex % digits -1`才能得到正确结果。

## 剑指offer面试题45--把数组排成最小的数

>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

这道题可以对数组排序，比如对于普通的数组{23, 12, 32}，可能会想到按照自然序排序后，得到{12, 23, 32}然后直接拼接起来就得到了最小的数字122332，但是像题中的例子按照自然序排好后就是{3, 32, 321}，如果直接拼接得到332321，是不是最小呢？可以发现排好后是{321, 32, 3}，才能得到最小数321323。**可见这已经不是自然序了，所以想到需要自定义一种比较方法，得到一种新的排序方式。**

既然是要拼接数组中所有的数，保证拼接后的数最小，我们从最小的问题出发，当数组中只有两个数时，情况很简单，比如{3, 32}，有用两种方式拼接他们`"3"+"32"`和`"32"+"3"`，分别为332和323，因为323 < 332，所以将32排在3的前面，也就是对于数组中的任意两个数m和n，如何mn < nm，则应该将m排在n的前面。在Java中很好实现，只需重写一个Comparator即可。使用Java 8的lambda表达式可以简化这一过程。

```java
package Chap5;

import java.util.ArrayList;
import java.util.List;

public class PrintMinNumber {
    public String printMinNumber(int[] numbers) {
        if (numbers == null || numbers.length == 0) return "";

        List<Integer> list = new ArrayList<>();
        for (int a : numbers) {
            list.add(a);
        }
        // 这句是核心，即比较ab和ba的大小，小的排在前面
        list.sort((a, b) -> (a + "" + b).compareTo(b + "" + a));
        StringBuilder sb = new StringBuilder();
        for (int a : list) {
            sb.append(a);
        }
        return sb.toString();
    }
}
```
