# 第5章-优化时间和空间效率

## 剑指offer面试题42--连续子数组的最大和

>输入一个整型数组，数组里正负数都可能有，数组中的一个或者连续的多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为O(n)

枚举所有的子数组，从中选择最大和可能是很容易想到的办法了，但是总共有$n(n+1) /2$个子数组，最快也需要$O(n^2)$时间复杂度，Pass。

我们可以举例分析数组的特点比如{1, -2, 3, 10, -4, 7, 2, -5}。首先记录下第一个元素，先假设它为最大和。当1加上-2时变成了-1，再加上3等于2，3前面加了一堆还不如不加，所以应该直接从3开始加，即**如果当前累加和是负数，那么它加上当前元素将使得新的累加和比当前元素还要小，此时应该将之前的累加和丢弃，从当前元素开始累加。**

按照上述方法，新的累加和为3大于当前最大和，因此最大和更新为3；加10，当前最大和变成13，继续-4，当前累加和为9，并不大于当前最大和，因此最大和不更新；加7、加2，当前和为18，大于最大和，当前最大和更新为18；最后-5，当前累加和为13，不大于最大和18。遍历完毕，返回最大和18.如果搞清楚了上面的思路，可以很容易写出如下代码:

```java
package Chap5;

public class FindGreatestSumOfSubArray {
    public int findGreatestSumOfSubArray(int[] array) {
        if (array == null || array.length == 0) return 0;

        int maxSum = array[0];
        int curSum = array[0];
        for (int i = 1; i < array.length; i++) {
            // 丢弃累结合，从当前元素开始累加
            if (curSum < 0) curSum = array[i];
            // 累加
            else curSum += array[i];
            // 和当前最大和比较，若比它大就更新
            if (curSum > maxSum) maxSum = curSum;
        }
        return maxSum;
    }
}

```

没几行，只需遍历一次，时间复杂度为O(n).

### 动态规划

还可以用动态规划的思想，用$f(i)$表示以第i个数字结尾的子数组，其中$0 \le i < n $，那么我们要求的就是$max[f(i)]$。

$$f(i) = array[i], i=0 或者f(i-1) < 0$$

$$f(i) = f(i -1) + array[i], i \neq 0 且f(i -1) \ge 0$$

**动态规划最重要的就是要保存中间计算结果**，这里$f(i)$其实就是上面的curSum，$max[f(i)]$的计算变成了两两比较，其实就是上面的maxSum。可以看到和上面的方法是异曲同工的。这里保存的中间计算结果就是curSum和maxSum，当$f(i-1) < 0$时对应着上面curSum < 0. 否则就累加，然后求$max[f(i)]$可以通过两两比较得到最终的最大和，也就是$f(i)$和当前的max比较选择较大的那个。

```java
package Chap5;

public class FindGreatestSumOfSubArray {
    /**
     * 动态规划，其实和上面是一样的代码...
     */
    public int FindGreatestSumOfSubArray2(int[] array) {
        if (array == null || array.length == 0) return 0;

        int maxSum = array[0];
        int curSum = array[0];
        for (int i = 1; i < array.length; i++) {
            // if (curSum + array[i] < array[i]),也就是if (curSum < 0) 则curSum的结果是array[i]
            // 否则curSum的值是curSum + array[i]
            curSum = Math.max(curSum + array[i], array[i]);
            // 如果curSum > maxSum,则maxSum取curSum，否则maxSum = maxSum
            maxSum = Math.max(curSum, maxSum);
        }
        return maxSum;
    }
}
```

## 剑指offer面试题43--1~n整数中1出现的次数

>输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数，例如输入12, 1~12中出现1的有1、10、11、12共5次

### 计算每个数字出现1的次数

比较直接的思路就是写一个方法可以统计任意整数1的个数，然后用一个循环得到对1~n每一个数调用该方法统计总的1的出现次数。

```java
package Chap5;

public class NumOf1 {
    /**
     * 方法1，计算每个数字中1的个数，复杂度O(nlgn)
     */
    public int NumberOf1From1To(int n) {
        // 正负数不影响1的个数，统一变成非负数
        if (n < 0) n = Math.abs(n);

        int count = 0;
        // 循环求n个数字，共O(nlgn)的时间
        for (int i = 1; i <= n; i++) {
            count += numOf1(i);
        }
        return count;
    }

    /**
     * O(lgn)的复杂度求一个数中含有1的数量
     */
    private int numOf1(int n) {
        int count = 0;
        while (n != 0) {
            if (n % 10 == 1) count++;
            n = n / 10;
        }
        return count;
    }
}

```

`numOf1`方法中，n % 10可以得到个位，n = n / 10表示丢弃最低位。该方法的复杂度为O(lgn)，对于1~n中n个数字都要调用一遍该方法，总的时间复杂度是O(nlgn)。

### 更暴力的解法--StringBuilder拼接

使用StringBuilder将1~n的所有数无缝拼接起来，然后一个个数。

```java
package Chap5;

public class NumOf1 {
    /**
     * 方法2：使用StringBuilder将所有数字拼接，无脑数数
     */
    public int numOf1Between1AndN(int n) {
        // 正负数不影响1的个数，统一变成非负数
        if (n < 0) n = Math.abs(n);

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append(i);
        }

        int count = 0;
        for (int i = 0; i < sb.length(); i++) {
            if (sb.charAt(i) == '1') {
                count++;
            }
        }
        return count;
    }
}
```

### 神一样的方法

参考[LeetCode](https://discuss.leetcode.com/topic/18054/4-lines-o-log-n-c-java-python)

1可以出现在任意一位，比如3245，1出现在个、十、百、千位都可以。只要固定某一位为1，计算出该位是1的所有情况，将固定每一位得到的情况数相加就是最终结果。

要固定某一位为1，可以使用m = 1, 10, 100, 1000....，对n作除、余操作，将输入整数分为高位和低位两部分。举个例子，对于输入n = 3101592，m = 100，如果令a = n / m, b = n % m，将得到a = 31015，b= 92两部分，现在固定百位为1（始终固定a的最低位），即`xxxx1xx`这样的形式，这样形式的数有多少个呢？

```s
0000 1 00
0000 1 01
.....
0000 1 99
0001 1 00
......
0001 1 99
0002 1 00
......
0002 1 99
......
3101 1 00
......
3101 1 99
```

为了看得直观，上面刻意将数字从百位处分隔开，对于百位之前的高位数，总共有`0000~3101`共3102种情况，而每一种情况对应着低位有`00~99`共100种情况，因此百位为1的情况数是3102*100，也就是`(a / 10 + 1) * m`种情况。好，现在得到百位为1的情况数了，个位与千位等其他位计算方法和上面类似，只需取不同的m就能将输入的整数分成两部分并固定某一位为1.

接下来m = 1000时，3101592被分成a = 3101和b = 592两部分，现在固定千位为1，但是此时千位本来就是1了，来看和上面有什么不同

```s
000 1 000
......
000 1 999
309 1 000
......
309 1 999
310 1 000
......
310 1 592
```

可以看到千位前的高位从`000~309`和上面一样，每一种情况都有`000~999`种可能，但是到310时，后面最多只能到592，共`000~592`是593种情况。此时千位为1的情况总数为：310 * 1000 + 593，即**当前要被固定的位在输入中本来就是1**的话有`(a / 10) * m + b + 1`种情况。

再看m = 10000，固定万位的情况。a = 310, b = 1592.

```s
00 1 0000
......
00 1 9999
30 1 0000
......
30 1 9999
```

没有了，共31 * 10000种，即**当前要被固定的位在输入中是0**的话有`(a / 10) * m`种情况。

一开始固定百位其实就是**当前要被固定的位在输入中是2~9**这种情况。

分析得差不多了，现在考虑这三种情况计算就好了。

```java
/**
 * 方法三
 */
public int numberOf1(int n) {
    int ones = 0;
    for (long m = 1; m <= n; m *= 10) {
        long a = n / m;
        long b = n % m;
        if (a % 10 == 0) ones += a / 10 * m;
        else if (a % 10 == 1) ones += (a / 10 * m) + (b + 1);
        else ones += (a / 10 + 1) * m;
    }
    return ones;
}
```

## 剑指offer面试题44--数字序列中的某一位数字

>数字以0123456789101112131415....的格式序列化得到一个字符序列中，在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字

### 逐个列举

有一种方法，每列举一个数字就记录当前序列长度和，比如列举到3，序列的长度和为4，列举到10，长度和为12...以此类推。当某次列举使得当前长度和大于给定的n时，停止列举，**第n位数一定在在刚列举的数中**，接下里只需从这个数中找出是哪一位即可。

```java
package Chap5;

public class ADigitInNumberSeq {
    /**
     * 方法1：逐个列举
     */
    public int numAtSeq(int index) {
        if (index < 0) return -1;

        int i = 0;
        int sum = 0;
        while (true) {
            sum += countDigits(i);
            // 一定不要包含=
            if (sum > index) break;
            i++;
        }
        // sum - n是超出的部分，减去1是因为下标从0开始
        return digitAt(i, sum - index - 1);
    }

    /**
     * 返回某数的第d位, 第0位是个位，第1位是十位，以此类推
     */
    private int digitAt(int value, int d) {
        return (value / (int) Math.pow(10, d)) % 10;
    }

    /**
     * 计算某数有多少位
     */
    private int countDigits(int num) {
        if (num == 0) return 1;

        int count = 0;
        while (num != 0) {
            num /= 10;
            count++;
        }
        return count;
    }
}

```

当前长度和sum > index时候退出循环，此时第index位一定在数字i中，那到底是数字i的第几位呢？举个例子

```s
012345678910111213...
```

找index = 16的数，当列举到13时候，当前长度和sum = 18 > 16，此时i = 17，容易得知index位是1，即17的第0位。多举几个例子就容易发现只要取数字`i`的第`sum - index -1`位就是我们要找的数字。

### 更快的方法

从数字本身的规律入手。如果要找第1001位，肯定不会考虑0~9折十位吧？接下来10-99也就有180位而已，不考虑，每次不考虑的情况需要减去已缩小查找范围，因此在排除掉0-99共180+10后还剩881，也就是说我们原来是从0开始找到第1001位，现在只需从100开始找到第991位即可。接下来看100-999共2700位，由于881  < 2700，所以这个数必然在100~999的范围内。881 = 270 * 3 + 1，说明这个数是100开始之后的第270个数的第1位（从0开始计算索引），也就是370的第一位数，即7。

有了思路后，要实现几个关键的方法，首先是根据位数得到一个区间的开始数字。区间划分为：0-9， 10-99， 100-999...比如n = 1，一位数的开始数是0; n = 2,两位数的开始数是10; n = 3,三位数的开始数是100...

其次因为要缩小查找范围，所以要根据位数知道该范围内总共有多少个数字，比如n = 1, 一位数0-9的范围共10个数；n = 2，两位数10-99的范围共90个数；n = 3，三位数100-999的范围共900个数....

还需要一个方法，一旦锁定范围，根据当前的位数能知道包含index处数字的数是几，然后从该数中找到要求的那位。

 ```java
package Chap5;

public class ADigitInNumberSeq {
    /*****************************************
     * 方法2
     */
    public int numAtSeq2(int index) {
        if (index < 0) return -1;
        // 位数，digits = 1表示一位数，0-9区间；digits = 2表示两位数，10-99区间...
        int digits = 1;
        while (true) {
            int numbers = numOfRange(digits);
            // 范围锁定，numbers * digits表示该区间共有多少位数字，如digits = 2，范围10-99就有180位
            if (index < numbers * digits) {
                return digitAt2(index, digits);
            }
            // 缩小范围
            index -= numbers * digits;
            digits++;
        }
    }

    /**
     * 根据位数得到范围内的个数，比如1位，0~9共10个
     * 2位，10~99共90个
     * 3位，100~999共900个
     * ...
     */
    private int numOfRange(int n) {
        if (n == 1) return 10;

        return (int) (9 * Math.pow(10, n - 1));
    }

    /**
     * n位数范围内的的第一个数，比如1位数，0~9，第一个是0
     * 2位数，10~99，第一个数是10
     * 3位数，100~199，第一个数是100
     */
    private int beginNumber(int n) {
        if (n == 1) return 0;
        return (int) Math.pow(10, n - 1);
    }
    // 锁定范围后，根据位数就能得到包含index处那位数的数字，然后从该数中找到要求的那位 
    private int digitAt2(int seqIndex, int digits) {
        int number = beginNumber(digits) + seqIndex / digits;
        return digitAt(number, digits - seqIndex % digits - 1);
    }

    public static void main(String[] args) {
        ADigitInNumberSeq a = new ADigitInNumberSeq();
        System.out.println(a.numAtSeq(1001)); // 7
        System.out.println(a.numAtSeq2(1001)); // 7
    }
}

 ```

重点看`digitAt2`方法

```java
private int digitAt2(int seqIndex, int digits) {
    int number = beginNumber(digits) + seqIndex / digits;
    return digitAt(number, digits - seqIndex % digits - 1);
}
```

`seqIndex / digits`表示该区间开始数字其后多少位是我们要找的数字，再加上`beginNumber(digits)`就得到了我们要找的数字，比如上面的例子811 / 3 = 270，说明是开始数字100其后的270位，于是我们知道了这个数是370，接下来`seqIndex % digits`取余操作可以得到数是370第1位，**由于得到的余数是从左往右数的，而digitAt方法是从右往左数的**。因此取`digits - seqIndex % digits -1`才能得到正确结果。

## 剑指offer面试题45--把数组排成最小的数

>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

这道题可以对数组排序，比如对于普通的数组{23, 12, 32}，可能会想到按照自然序排序后，得到{12, 23, 32}然后直接拼接起来就得到了最小的数字122332，但是像题中的例子按照自然序排好后就是{3, 32, 321}，如果直接拼接得到332321，是不是最小呢？可以发现排好后是{321, 32, 3}，才能得到最小数321323。**可见这已经不是自然序了，所以想到需要自定义一种比较方法，得到一种新的排序方式。**

既然是要拼接数组中所有的数，保证拼接后的数最小，我们从最小的问题出发，当数组中只有两个数时，情况很简单，比如{3, 32}，有用两种方式拼接他们`"3"+"32"`和`"32"+"3"`，分别为332和323，因为323 < 332，所以将32排在3的前面，也就是对于数组中的任意两个数m和n，如何mn < nm，则应该将m排在n的前面。在Java中很好实现，只需重写一个Comparator即可。使用Java 8的lambda表达式可以简化这一过程。

```java
package Chap5;

import java.util.ArrayList;
import java.util.List;

public class PrintMinNumber {
    public String printMinNumber(int[] numbers) {
        if (numbers == null || numbers.length == 0) return "";

        List<Integer> list = new ArrayList<>();
        for (int a : numbers) {
            list.add(a);
        }
        // 这句是核心，即比较ab和ba的大小，小的排在前面
        list.sort((a, b) -> (a + "" + b).compareTo(b + "" + a));
        StringBuilder sb = new StringBuilder();
        for (int a : list) {
            sb.append(a);
        }
        return sb.toString();
    }
}
```

## 剑指offer面试题46--把数字翻译成字符串

> 给定一个数字，我们按照如下的规则把它翻译成字符串
> 0 -> a
> 1 -> b
> 2 -> c
> ...
> 25 -> z
>
> 一个数字可能有多种翻译，比如12258有五种，分别是"bccfi", "bwfi","bczi","mcfi", "mzi".请实现一个函数，用来计算一个数字有多少种不同的翻译方法。

举个简单的例子，比如258，我们可以先翻译第一个数字，得到c，也可以翻译前两个数字，得到z；如果先翻译了一个数，对于剩下的58，和上面一样可以选择只翻译一位，得到f，也可以翻译两位（在这个例子中是不合法的，58没有与之映射的字符），如果先翻译了两位，对于剩下的8，只能有一种翻译方法了，得到i。所以最后得到两种翻译方法，cfi和zi。

从这个简单的例子可以得到一般性的结论，令f(i)为从第i位开始的不同翻译的数目，因为每次可以选择值翻译一个数字，也可一次翻译两个数字，而对于剩下的数字也可以采用同样的方法，这是一个递归问题。

$$f(i) = f(i+1) + g(i, i+1)f(i+2), 0 \le i < n$$

其中n为数字的位数，$g(i, i+ 1)$可取0或者1，当一次翻译两个数字时，如果这个数字在$10 \le m \le25$的范围内，这就是一个可翻译的数，此时$g(i, i + 1)$为1，否则为0。根据题意，我们最后就是要求得$f(0)$

### 从左到右翻译的递归

根据上面的思路，可写出从左到右翻译的递归解法。

```java
package Chap5;

import java.util.ArrayList;
import java.util.List;

public class TransLateNumToString {
    /**
     * 方法一：从左到右的递归，重复计算较多，但是可以保存编码的结果
     */
    public List<String> translateNum(int n) {
        List<String> list = new ArrayList<>();
        if (n < 0) return list;

        String number = String.valueOf(n);
        StringBuilder sb = new StringBuilder();
        translate(sb, number, list);
        return list;
    }

    private void translate(StringBuilder sb, String str, List<String> list) {
        if (str.equals("")) {
            list.add(sb.toString());
            return;
        }
        // 一次只翻译一个数
        String s1 = str.substring(0, 1);
        char letter1 = numToLetter(s1);
        sb.append(letter1);
        translate(sb, str.substring(1), list);
        sb.deleteCharAt(sb.length() - 1);
        // 一次翻译两个数
        if (str.length() >= 2) {
            String s2 = str.substring(0, 2);
            if (check(s2)) {
                char letter2 = numToLetter(s2);
                sb.append(letter2);
                translate(sb, str.substring(2), list);
                sb.deleteCharAt(sb.length() - 1);
            }
        }

    }
    /**
     * 当一次翻译两位数时，检查是否范围在10-25之间
     */
    private boolean check(String num) {
        int val = Integer.parseInt(num);
        return val >= 10 && val <= 25;
    }
    /**
     * 数字 -> 字母的映射，a的ASCII码是97，所以0-25的数字加上97就得到了题      * 目中的映射
     */ 
    private char numToLetter(String num) {
        return (char) (Integer.parseInt(num) + 97);
    }

}
```

使用StringBuilder拼接每次翻译的结果，到字符串的结尾说明翻译完毕，将该翻译结果存到一个list中，StringBuilder每次append一个翻译字符然后递归地对其后的字符进行同样的操作，但是递归结束后，StringBuilder需要删除掉这个刚添加了翻译字符，实际上就是模拟了进出栈的过程，这保证了StringBuilder在其他递归调用中表示的翻译字符结果正确。注意只有当当前字符串长度大于等于2才能一次翻译两个数字，因此在翻译两个数字时别忘了判断下。

这种方法，调用了很多次substring，空间上很浪费，而且自上而下的递归中有很多重复计算，效率并不高。但是该方法可以保存每种翻译的结果。

### 从右往左翻译的循环

如果自下而上，从小的结果出发，保存每一步计算的结果，以供下一步使用，也就是我们按照从右到左的顺序翻译。

$$f(i) = f(i+1) + g(i, i+1)f(i+2), 0 \le i < n$$

对于上面的公式，也就是先求出$f(n -1)$，然后求出$f(n -2)$，之后根据这两个值求出$f(n -3)$，然后根据$f(n-2)$和$f(n -3)$求出$f(n -4)$一直往左知道求出$f(0)$，这就是我们要的结果！

```java
package Chap5;

import java.util.ArrayList;
import java.util.List;

public class TransLateNumToString {
    /**
     * 方法二：从右到左的循环，效率高，单纯的计数
     */
    public int getTranslateCount(int n) {
        if (n < 0) return 0;
        return count(String.valueOf(n));
    }

    private int count(String num) {
        int len = num.length();
        int[] counts = new int[len];
        // f(n -1)必然为1
        counts[len - 1] = 1;

        for (int i = len - 2; i >= 0; i--) {
            int high = num.charAt(i) - '0';
            int low = num.charAt(i + 1) - '0';
            int combineNum = high * 10 + low;
            if (combineNum >= 10 && combineNum <= 25) {
                // f(i) = f(i+1) +f(i+2),if中因为f(i+2)不存在，但是该值肯定为1
                if (i == len -2) counts[i] = counts[i+1] + 1;
                else counts[i] = counts[i+1]+counts[i+2];
            } else {
                // f(i) = f(i+1)
                counts[i] = counts[i+1];
            }

        }
        // 从第一个数字开始的不同翻译数目
        return counts[0];
    }

    public static void main(String[] args) {
        TransLateNumToString t = new TransLateNumToString();
        System.out.println(t.translateNum(187534121).size());
        System.out.println(t.getTranslateCount(187534121));
    }
}

```

上面的代码就是把公式翻译了一遍，其中counnts数组存放每一步计算的结果，即保存$f(0)$~$f(n -1)$的值。$f(n -1)$说明只有一位数，必然只有一种翻译方法；同样注意，当$i = n -2$时候，$f(i+2)$将超出范围，需要特别处理，这种情况就是说，对于两位数比如18，肯定有两种翻译方法，即$f(n -1) + 1 = 2$种。

最后一步得到counts[0]即$f(0)$返回即为答案。

这种方法只需遍历数字的每一位即可，实现了题目的要求计算出了翻译数目，但是没有办法表示出翻译结果。

## 剑指offer面试题47--礼物的最大价值

> 在一个mxn的棋盘的每一格斗放油一个礼物，每个礼物都有一定的价值（大于0）从棋盘的左上角开始，每次可以往右边或者下边移动一格，知道到达棋盘的右下角。给定一个棋盘和上面的礼物，计算我们最多可以拿到多少价值的礼物

### 递归--两个方向的深度优先搜索

我第一想到的是递归，然后被书上打脸。不管，还是实现一下吧。

```java
package Chap5;

public class MaxGiftVal {
    /**
     * 方法一：递归，两个方向的深度优先搜索，用一个对象数组保存最大值（只需一个长度）
     */
    public int getMax(int[] gifts, int rows, int cols) {
        if (gifts == null || gifts.length == 0) return 0;
        int[] max = {0};
        select(gifts, 0, 0, rows, cols, 0, max);
        return max[0];
    }

    private void select(int[] gifts, int row, int col, int rows, int cols, int val, int[] max) {
        if (row >= rows || col >= cols) return;
        // 一维数组表示，对应着二维数组中的array[row][col]
        val += gifts[row * cols + col];
        // 到达右下角，和max比较
        if (row == rows - 1 && col == cols - 1) {
            if (val > max[0]) max[0] = val;
        }
        select(gifts, row + 1, col, rows, cols, val, max);
        select(gifts, row, col + 1, rows, cols, val, max);
    }
}
```

每进入一个格子，累加礼物价值。当到达右下角时，将累加和与全局的max变量比较，如果某条路径的累加和比max大，就更新max。边界控制很重要，在超出行或者超出列的范围后，直接返回。然后就不断在两个方向递归——右边或者下边。全局max由于是int型，作为参数并不能在递归调用后被改变，所以需要一个**对象**，由于只需要存放一个值，一个长度为1的对象数组即可。

### 动态规划--要到达当前格子有两个方向

设当前格子能获得的最大礼物价值为$f(i, j)$, 要到达该位置，只有两种情况：

- 从该位置的左边来，即$f(i, j-1)$
- 从该位置的上边来，即$f(i-1, j)$

$f(i, j)$处的礼物价值设为$gift(i, j)$

那么到达$f(i, j)$处能收集到的最大礼物价值为

$$max[f(i, j- 1), f(i-1, j)]+gift[i, j]$$

可以发现，要知道当前格子能获得最大礼物价值，需要用到当前格子左边一个和上面一个格子的最大礼物价值和。所以从左上角开始，计算到达每一个格子能获得最大礼物价值是多少，并保存下这些结果。在后面求其他格子的最大礼物价值时会用到前面的结果。基于这个思路可写出如下代码。

```java
package Chap5;

    /**
     * 方法2：动态规划，到达f(i,j)处拥有的礼物价值和有两种情况：
     * 1、从左边来，即f(i, j) = f(i, j -1) + gift(i, j)
     * 2、从上边来，即f(i, j) = f(i -1, j) + gift(i, j)
     *
     * 保证到达每一个格子得到的礼物价值之和都是最大的，也就是取max[f(i, j-1), f(i-1, j)] +gift(i, j)
     * 可以发现，要知道当前格子能获得最大礼物价值，需要用到当前格子左边一个和上面一个格子的最大礼物价值和
     */

    public int getMaxVal(int[] gifts, int rows, int cols) {
        if (gifts == null || gifts.length == 0) return 0;
        int[][] maxVal = new int[rows][cols];
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int left = 0;
                int up = 0;
                if (row > 0) up = maxVal[row -1][col];
                if (col > 0) left = maxVal[row][col -1];
                maxVal[row][col] = Math.max(up, left) + gifts[row *cols+col];
            }
        }
        return maxVal[rows-1][cols-1];
    }
```

用到一个二维数组保存到达每一个格子时能获得的最大礼物价值。up和left分别是上面说的$f(i-1, j)$和$f(i, j -1)$，循环完毕后，返回到达右下角处能获得最大礼物价值即可。

### 上面方法的优化——用一维数组代替二维数组

当前礼物的最大价值只依赖$f(i-1, j)$和$f(i, j -1)$这两个格子，因此只需要当前行i，第j列的前面几个格子，也就是$f(i, 0)$~$f(i, j-1)$；以及i -1行的，第j列及其之后的几个格子，也就是$f(i-1, j)$~$f(i-1, cols-1)$

两部分加起来的个数刚好是棋盘的列数cols。所以只需要一个长度为cols的一维数组即可，优化如下。

```java
package Chap5;

    public int betterGetMaxVal(int[] gifts, int rows, int cols) {
        if (gifts == null || gifts.length == 0) return 0;
        int[] maxVal = new int[cols];
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int left = 0;
                int up = 0;
                if (row > 0) up = maxVal[col];
                if (col > 0) left = maxVal[col -1];
                maxVal[col] = Math.max(up, left) + gifts[row *cols+col];
            }
        }
        return maxVal[cols-1];
    }
```

`int[] maxVal = new int[cols];` 中，索引为`0~j-1`的就是$f(i, 0)$~$f(i, j-1)$，索引`j~cols-1`的就是$f(i-1, j)$~$f(i-1, cols-1)$

## 剑指offer面试题48--最长不含重复字符串的子字符串

> 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含'a'~'z'之间的字符，例如在字符串"arabcacfr"中，最长的不含重复字符的子字符串是"acfr"，长度为4

动态规划，**定义$f(i)$表示以第i个字符为结尾的不含重复字符的子字符串长度。**

如果第i个字符之前没有出现过，则$f(i) = f(i -1) +1$，比如‘abc',$f(0) = 1$是必然的，然后字符’b‘之前没有出现过，则$f(1) = f(0)+1$, 字符’c'之前没有出现过，那么$f(2) = f(1) +1$,每次计算都会用到上一次计算的结果。

如果第i个字符之前出现过呢？找到该字符上次出现的位置preIndex，当前位置i - preIndex就得到这两个重复字符之间的距离，设为d。此时有两种情况

- 如果`d <= f(i-1)`,说明当前重复字符必然在f(i-1)所对应的字符串中，比如’bdcefgc‘，当前字符c前面出现过了，preIndex为2，此时`d = 6 -2 = 4` ,小于`f(i -1) = 6 (bdcefg)`我们只好丢弃前一次出现的字符c及其前面的所有字符，得到当前最长不含重复字符的子字符串为’efgc‘，即`f(i) = 4`, 多举几个例子就知道，应该让`f(i) = d`；

- 如果`d > f(i-1)`, 这说明当前重复字符必然在f(i-1)所对应的字符串**之前**，比如`erabcdabr`当前字符r和索引1处的r重复，`preIndex =1, i = 8,d = 7`。而`f(i -1) = 4 (cdab)`,此时直接加1即可，即`f(i) = f(i-1) +1`

根据这两种情况可写出代码如下：

```java
package Chap5;

public class LongestSubstring {
    public  int lengthOfLongestSubstring(String str) {
        if (str == null || str.length() == 0) return 0;
        int curLen = 0;
        int maxLen = 0;
        // 0~25表示a~z，position[0] = index,表明a上次出现在index处
        int[] position = new int[256];
        for (int i = 0; i < 256; i++) {
            position[i] = -1;
        }

        for (int i = 0; i < str.length(); i++) {
            int preIndex = position[str.charAt(i)];
            // 字符第一次出现，或者d > f(i -1)
            if (preIndex == -1 || i - preIndex > curLen) curLen++;
            // d <= f(i -1) 
            else {
                curLen = i - preIndex;
            }
            // 记录当前字符出现的位置
            position[str.charAt(i)] = i;
            if (curLen > maxLen) maxLen = curLen;
        }
        return maxLen;

    }
}
```

用了一个数组position代替哈希表，记录每个字符上次出现的位置，能以O(1)的时间完成，先要将position中的值全初始化为-1，因为上次出现的位置可能含有索引0。 curLen就是上面说到的$f(i -1)$

如果某个字符第一次出现，那么它上次出现的位置preIndex为-1。当前最长不重复子字符串直接加1。

只有else语句中curLen才可能变小，因此要即使保存到maxLen，因为这个curLen可能就是最长的。而且if语句中curLen++并没有和maxLen比较，所以除了循环后还要再和maxLen比较一次。

## 剑指offer面试题49--丑数

> 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

穷举法，挨个判断是否是丑数，即使那个数不是丑数也要判断，显然时间复杂度太高。

有没有方法每一步计算只是得到丑数呢？根据丑数的定义，所有丑数都是2、3、5这三个因子的任意搭配的任意多次乘积，比如2x2，2x3, 2x2x3x5等等。那么从1开始，分别乘以2、3、5，得到2、3、5三个丑数，但是这并不是正确的排序，我们知道3、5之间还有个4也是丑数。1之后的下一个丑数，一定是2、3、5其中的一个，显然应该选三者中最小的2，现在丑数集合为{1, 2}且有序，刚才选走的2是1x2得到的，因此下一个和2相乘的丑数应该是1之后的数字2（丑数集合已经有序，直接选择下一个）。现在又得到三个候选的丑数4、3、5，再次选择三者中最小的3，得到当前丑数集合{1, 2, 3}，刚被选走的3由1x3得到，因此下一个要和3相乘的按照丑数集合的顺序应该是2，然后又得到了三个候选的丑数4、6、5，选择最小的4.....不断重复，自始至终只和丑数打交道。

设定三个数t2、t3、t3专门用于分别和2、3、5相乘，某次选择中选走了ti，那么ti从丑数集合中选择下一个数，下次再和i相乘生成一个新的候选丑数，本次没有被选中的，下次继续参与比较。这样能保证下一个丑数一定在三个候选项中，且是三个候选项中最小的那个。

```java
package Chap5;

public class UglyNumber {
    public int uglyNumber(int index) {
        if (index <= 0) return 0;
        int t2 = 0;
        int t3 = 0;
        int t5 = 0;
        int[] res = new int[index];
        // 第一个丑数为1
        res[0] = 1;
        for (int i = 1; i < index; i++) {
            int m2 = res[t2] * 2;
            int m3 = res[t3] * 3;
            int m5 = res[t5] * 5;
            // 三个候选中最小的就是下一个丑数
            res[i] = Math.min(m2, Math.min(m3, m5));
            // 选择某个丑数后ti * i，指针右移从丑数集合中选择下一个丑数和i相乘，注意是三个连续的if，也就是三个if都有可能执行。这种情况发生在三个候选中有多个最小值，指针都要右移，不然会存入重复的丑数
            if (res[i] == m2) t2++;
            if (res[i] == m3) t3++;
            if (res[i] == m5) t5++;
        }
        return res[index - 1];
    }
}
```

## 剑指offer面试题50--第一个只出现一次的字符

> 找出字符串中找出第一个只出现一次的字符，比如输入“abacceff",则输出'b'

要想知道某个字符是不是只出现了一次，必须遍历字符串的每个字符。**因此可以先遍历一次，统计每个字符出现次数。再遍历一次，遇到某个字符出现字符为1就立即返回。**统计每个字符出现次数，可以用哈希表，不过如果输入中都是ASCII码，那么使用0-255表示即可。这样使用一个`int[] count = new int[256]`就能代替哈希表了，以`count[someChar] = times`这种方式表示某个字符出现的次数。比如‘a’的ASCII码是97，那么count[97]就表示了字符'a'的出现次数，以此类推。

```java
package Chap5;

public class FirstAppearOnceChar {
    /**
     * 返回第一个不重复字符
     */
    public char firstNotRepeatingChar(String str) {
        if (str == null || str.length() == 0) return '\0';
        int[] count = new int[256];

        for (int i = 0; i < str.length(); i++) {
            count[str.charAt(i)]++;
        }
        for (int i = 0; i < str.length(); i++) {
            if (count[str.charAt(i)] == 1) return str.charAt(i);
        }
        return '\0';
    }

    /**
     * 返回第一个不重复字符在字符串中的索引
     */
    public int firstAppearOnceChar(String str) {
        if (str == null || str.length() == 0) return -1;
        int[] count = new int[256];

        for (int i = 0; i < str.length(); i++) {
            count[str.charAt(i)]++;
        }
        for (int i = 0; i < str.length(); i++) {
            if (count[str.charAt(i)] == 1) return i;
        }
        return -1;
    }
}
```

上面两个方法，一个是返回第一个只出现一次的字符，一个返回第一个只出现一个的字符的索引，思路都一样。根据`count[someChar]`获取某个字符的出现次数时间复杂度为O(1),对于长度为n的字符串，总的复杂度为O(n).

不过如果输入中含有特殊符号或者中文等，256位的ASCII表就不够用了，需要上Unicode了，总之看题目要求吧，要想通用就哈希表。

### 相关题目

#### 扩展一

> 定义一个函数，输入两个字符串，从第一个字符串中删除在第二个字符串中出现过的所有字符。比如第一个字符串"google"，第二个字符串为"aeiou"，删除后得到"ggl".

使用一个`boolean occur[] = new int[256]`布尔型数组，对于第二个字符串中的每个字符，标记为true表示出现过。遍历第一个字符串，判断每个字符在occur中是不是fale，为false说明该字符没有在第二个字符串中出现过，保留。

```java
/**
 * 从第一个字符串中删除第二个字符串中出现过的所有字符
 */
public String deleteFromAnother(String str, String another) {
    if (str == null || str.length() == 0 || another == null || another.length() == 0) return str;
    boolean[] occur = new boolean[256];
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < another.length(); i++) {
        occur[another.charAt(i)] = true;
    }

    for (int i = 0; i < str.length(); i++) {
        if (!occur[str.charAt(i)]) sb.append(str.charAt(i));
    }
    return sb.toString();
}
```

#### 扩展二

> 定义一个函数，删除一个字符串中所有重复出现的字符，比如输入"google"返回"gole"

使用一个`boolean occur[] = new int[256]`布尔型数组，记录某个字符是否出现过。刚开始都初始化false，每添加一个字符就标记为true，这样下次遇到重复字符就不会再添加了。

```java
/**
 * 删除字符串中所有的重复字符
 */
public String deleteRepeating(String str) {
    if (str == null || str.length() == 0) return str;

    boolean[] occur = new boolean[256];
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < str.length(); i++) {
        char ch = str.charAt(i);
        if (!occur[ch]) sb.append(ch);
        occur[ch] = true;
    }
    return sb.toString();
}
```

#### 扩展三

> 变位词，如果两个单词含有相同的字母且每个字母出现的次数还一样，那么这两个单词互为变位词。定义一个函数判断两个字符串是不是互为变位词。

两个字符串含有相同的字母、每个字母出现的次数一样，先统计第一个字符串每个字符出现的次数，然后遍历第二个字符串，对于每个出现的字符，将统计表中相应字符的出现次数减1，**如果啷个字符串是变位词，那么遍历结束后，统计表中每个字符出现的字符都是0**。

```java
/**
 * 变位词
 */
public boolean hasSameChar(String s1, String s2) {
    if (s1 == null || s2 ==null) return false;
    int[] count = new int[256];
    // 统计第一个字符串
    for (int i = 0; i < s1.length(); i++) {
        count[s1.charAt(i)]++;
    }
    // 第二个字符串中如果有该字符，就减去
    for (int i = 0; i < s2.length(); i++) {
        count[s2.charAt(i)]--;
    }
    // 如果是变位词，最后count数组每个位置都是0
    for (int i = 0; i < 256; i++) {
        if (count[i] != 0) return false;
    }
    return true;
}
```

#### 题目二

> 字符流中第一个只出现一次的字符。
> 这次字符串是动态变化的了，比如现在只从字符流中读取了两个字符为"go"那么字符流中第一个只出现一次的字符是'g'，等到从字符流中读取了前6个字符"google"时，第一个只出现一次的字符变成了'l'.

使用一个insert函数模拟从字符流中读到一个字符。这次统计表`int[] occur = new int[256]`记录的是字符出现的索引.

- 如果某个字符出现过，那么`occur[someChar] >= 0`;
- 对于没有出现过的字符，令`occur[someChar] = -1`;
- 如果某个字符第二次出现，令`occur[someChar] = -2`。

要获得当前字符串中第一个只出现一次的，只需从所有`occur[someChar] >= 0`中结果中找出出现索引最小的那个字符即可。

```java
package Chap5;

public class AppearOnceInStream {
    // 记录某个字符出现的索引
    private int[] count;
    // 当前读取到的字符在字符串中的索引
    private int index;
    public AppearOnceInStream() {
        count =  new int[256];
        for (int i = 0; i < count.length; i++) {
            count[i] = -1;
        }
    }
    // 模拟读取字符流中的下一个字符
    public void insert(char c) {
        if (count[c] == -1) count[c] = index;
        else if (count[c] >= 0) count[c] = -2;
        index++;
    }

    public char firstAppearOnceChar() {
        int minIndex = Integer.MAX_VALUE;
        char c = '\0';
        for (int i = 0; i < count.length; i++) {
            // 从所有count[i] >= 0的结果中找出最小的索引就是第一个只出现一次的字符
            if (count[i] >= 0 && count[i] < minIndex) {
                minIndex = count[i];
                c = (char)i;
            }
        }
        return c;
    }

    public static void main(String[] args) {
        AppearOnceInStream a = new AppearOnceInStream();
        a.insert('g');
        a.insert('o');
        System.out.println(a.firstAppearOnceChar());
        a.insert('o');
        a.insert('g');
        a.insert('l');
        a.insert('e');
        System.out.println(a.firstAppearOnceChar());
    }
}
```

## 剑指offer面试题51--在排序数组中查找数字

> 统计一个数字在排序数组中出现的次数。

### 遍历

这是很容易想到的方法了，但时间复杂度O(n)，不推荐。

```java
package Chap6;

public class NumOfK {
    /**
     * 方法一：遍历，O(n)复杂度，不推荐
     */
    public int getNumberOfK(int[] array, int k) {
        if (array == null) return 0;

        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i] == k) {
                count++;
            }
        }
        return count;
    }
}
```

### 二分法

既然是排序数组，自然容易想到二分法查找。假设要查找的数字为k，只需找到第一个k的下标、最后一个k的下标，就达到了计数的目的。

先来找第一个k的下标：由于有多个k，因此当在mid处找到k时，不要急于返回。如果k之前的数还是k，那么我们还要继续在左子数组中查找，直到某个mid处的值为k但是它前面的值不是k、或者mid都等于0了（即第一个k出现在下标0处）；

然后找最后一个k的下标：同样地，如果mid处是k，且它的后面还是k，需要在右子数组中继续查找，直到mid处为k但它后面不是k、或者mid都等于array.length -1(即最后一个k出现在数组的最后一个位置)；

得到第一个k和最后一个k的下标后，只需将两个索引相减再加上1即可。

根据上面的描述，可写出如下代码

```java
package Chap6;

public class NumOfK {
    /**
     * 方法二：二分法找到第一个k和最后一个k，时间复杂度O(nlgn)
     */
    public int numberOfK(int[] array, int k) {
        if (array == null) return 0;
        int from = getFirstOfK(array, k, 0, array.length - 1);
        int to = getLastOfK(array, k, 0, array.length - 1);
        if (from == -1 && to == -1) return 0;
        else return to - from + 1;
    }
    // 找到第一个k的下标
    private int getFirstOfK(int[] array, int k, int low, int high) {
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (k < array[mid]) high = mid - 1;
            else if (k > array[mid]) low = mid + 1;
            else {
                if (mid > 0 && array[mid - 1] == k) high = mid - 1;
                else return mid;
            }
        }
        return -1;
    }
    // 找到最后一个k的下标
    private int getLastOfK(int[] array, int k, int low, int high) {
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (k < array[mid]) high = mid - 1;
            else if (k > array[mid]) low = mid + 1;
            else {
                if (mid < array.length - 1 && array[mid + 1] == k) low = mid + 1;
                else return mid;
            }
        }
        return -1;
    }
}
```

### 更巧妙的二分法

注意到要查找的数组元素都是int型的，我们知道普通二分查找只需稍微改变下返回值（返回low），就能得到一个排名方法——在数组中比k小的数有多少个，即k在数组中排名多少。有个很聪明的思路就是，在数组中查找接近k的浮点数。

```java
private int rank(int[] array, double k) {
    int low = 0;
    int high = array.length - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (k < array[mid]) high = mid - 1;
        else if (k > array[mid]) low = mid + 1;
    }
    // 和普通二分查找不同，从原来的-1改成返回low
    return low;
}
```

比如数组{1, 2, 3 ,3, 3, 3, 4, 5}中要查找3的个数。我们在数组中查找2.5，得到2.5在数组中的排名是2！同样在数组中查找3.5，得到3.5在数组中的排名是6。注意2.5和3.5之间夹的都是3！用这两个下标6 -2 = 4得到的刚好就是3的个数。

这是种很巧妙的方法，同样是O(lgn)的复杂度，这个方法的代码量少了很多。

```java
public int numOfK(int[] array, int k) {
    if (array == null) return 0;
    return rank(array, k + 0.5) - rank(array, k - 0.5);
}
```

### 题目2

> 0~n-1中缺失的数
> 一个长度为n -1的递增排序数组中的所有数字都是唯一的，并且每个数字的都在范围0~n-1之内。在范围内0~n-1内的n个数字中有且只有一个数字不在该数组中，找出这个数字

举个简单的例子来找到规律。比如数组长度为8，那么该数组中的数字都是0-8之间的，但是缺了一个数字，比如缺了4，则该数组为{0, 1, 2, 3, 5, 6, 7,8}

可以发现，缺失数字还没出现时，始终有**该数字在数组中的下标等于该数，即array[i] == i**,但是从5开始不再有这样的关系。对于5及其之后的元素有array[i] == i+1，但是5之前的3仍然有array[3] == 3, 可以看到这是一个分界线。此时返回5所在的下标4就是我们要的答案。

如果找到这个分界线呢？数组是有序的，仍然采用二分查找。当mid处满足array[mid] == mid，说明mid处及其之前的数都没有缺失，因此可以直接在mid右边数组查找；当array[mid] != mid说明mid处之前有元素丢失，此时再判断一下mid前的一个元素是否也有元素丢失，如果没有说明mid处是第一个值和下标不相等的元素，返回下标mid就是答案；如果mid处的前一个元素也有元素丢失，就继续缩小查找范围，在mid的左边数组继续查找即可。

根据上面的描述，写出如下代码：

```java
package Chap6;

public class FindTheLossNumber {
    public int findLoss(int[] array) {
        if (array == null) return -1;
        int low = 0;
        int len = array.length;
        int high = len - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (mid != array[mid]) {
                if (mid == 0 || mid -1 == array[mid -1]) return mid;
                else high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        if (low == len) return len;
        //  无效的输入数组，如不是递增排序，或者有的数字超出了0~n-1的范围
        return -1;
    }
}

```

注意上面还有句当mid != array[mid]时，如果mid == 0的情况，说明数组的第一个元素其下标就不等于值，很容易想到就是缺失了0，因此返回mid == 0也是正确的。这种情况也就是{1, 2, 3, 4, 5, 6,7,8} 缺少了0；

如果缺少的是0~n-1中的最后一位，即{0, 1, 2, 3, 4, 5, 6,7}, 此时缺少8，正好是数组的长度。这种情况最后会因为low = mid +1而使得low变成array.length，代码中也考虑到了，出了循环后判断了一下，此时返回array.length就是正确答案。

### 题目3

> 数组中数值和下标相等的元素。
> 假设一个单调递增的数组里的每个元素都是整数并且是唯一的。找出数组中任意一个数值等于其下标的元素。比如在数组{-3， -1， 1， 3， 5}，数字3和它的下标相等

又是递增数组，二分查找。

这次只需查找到array[mid] == mid就可以直接返回了，因为题目要求任意一个都行嘛。考虑array[mid] < mid的情况，由于数组有序，那么mid之前的元素同样有array[i] < i，这就是说我们不用考虑mid的左边数组，在右边数组查找即可；当array[mid] > mid时，由于数组有序，mid后面的元素都有array[i] > i, 因此不用考虑mid的右边数组，只在左边数组中查找即可。

听起来和普通的二分查找很像，实际上代码几乎一样。只是拿mid和array[mid]比较了，而不是某个要查找的k和array[mid]比较。

```java
package Chap6;

public class ValEqualsIndex {
    public int findValEqualsIndex(int[] array) {
        if (array == null) return -1;
        int low = 0;
        int high = array.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (mid > array[mid]) low = mid + 1;
            else if (mid < array[mid]) high = mid - 1;
            if (mid == array[mid]) return mid;
        }
        return -1;
    }
}
```
